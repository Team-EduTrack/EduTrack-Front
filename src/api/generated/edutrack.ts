/**
 * Generated by orval v7.17.0 üç∫
 * Do not edit manually.
 * EduTrack API
 * EduTrack Î∞±ÏóîÎìú(Spring Boot 3, Java 17)Ïö© OpenAPI Ïä§Ìéô
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import * as axios from 'axios';
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios';

export interface SignInRequest {
  loginId: string;
  password: string;
}

export interface SignInResponse {
  accessToken?: string;
  refreshToken?: string;
  user?: UserInfo;
}

export interface UserInfo {
  id?: number;
  name?: string;
  role?: string;
}

export interface MyInfoResponse {
  id?: number;
  name?: string;
  email?: string;
  phone?: string;
  role?: string;
}

export interface SignupRequest {
  loginId: string;
  password: string;
  name: string;
  phone: string;
  email: string;
  academyCode: string;
}

export interface SignupResponse {
  id?: number;
  loginId?: string;
  name?: string;
  role?: string;
}

export interface SendEmailVerificationRequest {
  email: string;
}

export interface VerifyEmailRequest {
  email: string;
  token: string;
}

export interface UserSearchResultResponse {
  id?: number;
  name?: string;
  loginId?: string;
  phone?: string;
  role?: string;
}

export interface PrincipalRegistrationRequest {
  principalName: string;
  loginId: string;
  password: string;
  passwordConfirm: string;
  phone: string;
  email: string;
  academyName: string;
}

export interface PrincipalRegistrationResponse {
  id?: number;
  academyName?: string;
  academyCode?: string;
}

export type LectureCreationRequestDate = typeof LectureCreationRequestDate[keyof typeof LectureCreationRequestDate];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LectureCreationRequestDate = {
  MONDAY: 'MONDAY',
  TUESDAY: 'TUESDAY',
  WEDNESDAY: 'WEDNESDAY',
  THURSDAY: 'THURSDAY',
  FRIDAY: 'FRIDAY',
  SATURDAY: 'SATURDAY',
  SUNDAY: 'SUNDAY',
} as const;

export interface LectureCreationRequest {
  title: string;
  description?: string;
  date: LectureCreationRequestDate;
  startDate: string;
  endDate: string;
}

export interface LectureCreationResponse {
  lectureId?: number;
}

export interface LectureForTeacherResponse {
  lectureId?: number;
  title?: string;
  studentCount?: number;
}

export type LectureDetailForTeacherResponseAllOf = {
  description?: string;
  studentDetails?: StudentInfo[];
  assignmentsWithSubmissions?: AssignmentWithSubmissions[];
  examsWithParticipation?: ExamParticipationInfo[];
};

export type LectureDetailForTeacherResponse = LectureForTeacherResponse & LectureDetailForTeacherResponseAllOf;

export interface StudentInfo {
  id?: number;
  name?: string;
}

export interface AssignmentWithSubmissions {
  assignmentId?: number;
  assignmentTitle?: string;
  submittedStudents?: SubmissionStudentInfo[];
}

export interface SubmissionStudentInfo {
  studentId?: number;
  studentName?: string;
  submissionId?: number;
}

export interface ExamParticipationInfo {
  examId?: number;
  examTitle?: string;
  participatedCount?: number;
  totalStudentCount?: number;
}

export interface LectureDetailWithStatisticsResponse {
  lectureDetailForTeacherResponse?: LectureDetailForTeacherResponse;
  lectureStatisticsResponse?: LectureStatisticsResponse;
}

export interface LectureStatisticsResponse {
  lectureId?: number;
  studentCount?: number;
  attendanceRate?: number;
  assignmentSubmissionRate?: number;
  examParticipationRate?: number;
  averageScore?: number;
  total10PercentScore?: number;
}

export interface StudentSearchResponse {
  studentId?: number;
  name?: string;
}

export interface LectureStudentAssignRequest {
  studentIds: number[];
}

export interface LectureStudentAssignResponse {
  lectureId?: number;
  assignedCount?: number;
}

export interface AssignmentCreateRequest {
  lectureId: number;
  title: string;
  description?: string;
  dueDate: string;
}

export interface AssignmentCreateResponse {
  assignmentId?: number;
}

export interface PresignedUrlRequest {
  fileName: string;
  contentType?: string;
}

export interface PresignedUrlResponse {
  url?: string;
  fileKey?: string;
}

export interface AssignmentSubmitRequest {
  fileKey?: string;
  comment?: string;
}

export interface AssignmentSubmitResponse {
  submissionId?: number;
  submittedAt?: string;
}

export type AssignmentListResponseStatus = typeof AssignmentListResponseStatus[keyof typeof AssignmentListResponseStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AssignmentListResponseStatus = {
  NOT_SUBMITTED: 'NOT_SUBMITTED',
  SUBMITTED: 'SUBMITTED',
} as const;

export interface AssignmentListResponse {
  assignmentId?: number;
  title?: string;
  endDate?: string;
  status?: AssignmentListResponseStatus;
}

export interface AssignmentSubmissionListResponse {
  submissionId?: number;
  studentId?: number;
  studentName?: string;
  fileUrl?: string;
  submittedAt?: string;
}

export interface AssignmentSubmissionStudentViewResponse {
  submissionId?: number;
  assignmentId?: number;
  lectureName?: string;
  teacherName?: string;
  studentLoginId?: string;
  studentName?: string;
  assignmentTitle?: string;
  assignmentDescription?: string;
  filePath?: string;
  /** @nullable */
  score?: number | null;
  /** @nullable */
  feedback?: string | null;
}

export interface AssignmentSubmissionTeacherViewResponse {
  submissionId?: number;
  assignmentId?: number;
  lectureName?: string;
  teacherName?: string;
  studentLoginId?: string;
  studentName?: string;
  assignmentTitle?: string;
  assignmentDescription?: string;
  filePath?: string;
  /** @nullable */
  score?: number | null;
  /** @nullable */
  feedback?: string | null;
}

export interface AssignmentGradeRequest {
  /**
   * @minimum 0
   * @maximum 100
   */
  score: number;
  feedback?: string;
}

export interface AssignmentGradeResponse {
  submissionId?: number;
  assignmentId?: number;
  studentId?: number;
  score?: number;
  feedback?: string;
}

export interface ExamCreationRequest {
  title: string;
  description?: string;
  startTime: string;
  endTime: string;
}

export interface ExamCreationResponse {
  examId?: number;
}

export type QuestionRegistrationRequestDifficulty = typeof QuestionRegistrationRequestDifficulty[keyof typeof QuestionRegistrationRequestDifficulty];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const QuestionRegistrationRequestDifficulty = {
  EASY: 'EASY',
  MEDIUM: 'MEDIUM',
  HARD: 'HARD',
} as const;

export interface QuestionRegistrationRequest {
  questionText: string;
  choices: string[];
  correctAnswerIndex: number;
  difficulty: QuestionRegistrationRequestDifficulty;
  unitId: number;
}

export interface QuestionIdResponse {
  questionId?: number;
}

export interface ExamDetailResponse {
  examId?: number;
  lectureId?: number;
  title?: string;
  startDate?: string;
  endDate?: string;
  durationMinute?: number;
  status?: string;
  questions?: QuestionDetail[];
}

export interface QuestionDetail {
  questionId?: number;
  content?: string;
  score?: number;
  answerNumber?: number;
  difficulty?: string;
  unitId?: number;
  choices?: ChoiceDetail[];
}

export interface ChoiceDetail {
  choiceId?: number;
  content?: string;
  choiceNumber?: number;
}

export interface ExamStartResponse {
  examId?: number;
  studentId?: number;
  title?: string;
  startDate?: string;
  endDate?: string;
  durationMinute?: number;
  startedAt?: string;
  examStartedAt?: string;
  personalDeadline?: string;
  status?: string;
  questions?: QuestionForStudent[];
}

export interface QuestionForStudent {
  questionId?: number;
  content?: string;
  score?: number;
  difficulty?: string;
  choices?: ChoiceForStudent[];
}

export interface ChoiceForStudent {
  choiceId?: number;
  content?: string;
  choiceNumber?: number;
}

export interface AnswerSaveRequest {
  answers: AnswerSubmitRequest[];
}

export interface AnswerSubmitRequest {
  questionId: number;
  selectedAnswerNumber: number;
}

export interface AnswerSaveResponse {
  examId?: number;
  studentId?: number;
  savedCount?: number;
  savedAt?: string;
}

export interface ExamSubmitResponse {
  examId?: number;
  studentId?: number;
  submittedAt?: string;
  message?: string;
}

export interface ExamResultResponse {
  examId?: number;
  examTitle?: string;
  studentId?: number;
  studentName?: string;
  status?: string;
  totalScore?: number;
  earnedScore?: number;
  correctCount?: number;
  totalQuestionCount?: number;
  startedAt?: string;
  submittedAt?: string;
  questionResults?: QuestionResult[];
}

export interface QuestionResult {
  questionId?: number;
  content?: string;
  score?: number;
  submittedAnswer?: number;
  correctAnswer?: number;
  isCorrect?: boolean;
  unitId?: number;
  difficulty?: string;
  earnedScore?: number;
}

export interface ExamRecordResponse {
  examId?: number;
  examTitle?: string;
  lectureName?: string;
  status?: string;
  totalScore?: number;
  earnedScore?: number;
  startedAt?: string;
  submittedAt?: string;
  examStartDate?: string;
  examEndDate?: string;
}

export interface QuestionCorrectRateResponse {
  questionId?: number;
  questionContent?: string;
  totalCount?: number;
  correctCount?: number;
  correctRate?: number;
}

export interface StudentQuestionStatisticsResponse {
  questionId?: number;
  questionContent?: string;
  correctAnswer?: number;
  /** @nullable */
  submittedAnswer?: number | null;
  isCorrect?: boolean;
  earnedScore?: number;
  maxScore?: number;
  totalCount?: number;
  correctCount?: number;
  correctRate?: number;
}

export interface MyLectureResponse {
  lectureId?: number;
  lectureTitle?: string;
  teacherName?: string;
  startDate?: string;
  endDate?: string;
}

export interface AttendanceCheckInResponse {
  studentId?: number;
  attendanceDate?: string;
  alreadyCheckedIn?: boolean;
}

export interface AssignmentSummaryResponse {
  assignmentId?: number;
  lectureTitle?: string;
  title?: string;
  startDate?: string;
  endDate?: string;
  /** @nullable */
  score?: number | null;
}

export interface ExamSummaryResponse {
  examId?: number;
  lectureTitle?: string;
  title?: string;
  startDate?: string;
  endDate?: string;
  /** @nullable */
  earnedScore?: number | null;
  status?: string;
}

export interface StudentAnalysisResponse {
  studentId?: number;
  /** @nullable */
  avgScore?: number | null;
  unitWeak?: string[];
  trend?: number[];
}

export interface StudentExamSummaryResponse {
  examId?: number;
  examTitle?: string;
  lectureName?: string;
  /** @nullable */
  totalScore?: number | null;
  /** @nullable */
  earnedScore?: number | null;
  /** @nullable */
  submittedAt?: string | null;
}

export interface StudentUnitCorrectRateResponse {
  unitId?: number;
  studentId?: number;
  totalTryCount?: number;
  correctCount?: number;
  correctRate?: number;
}

export interface StudentLectureAttendanceResponse {
  lectureId?: number;
  lectureName?: string;
  year?: number;
  month?: number;
  attendedDates?: string[];
  totalClassDays?: number;
  attendedDays?: number;
  attendanceRate?: number;
  otherStudentsAvgAttendanceRate?: number;
}

export type SearchUsersParams = {
role?: SearchUsersRole;
keyword?: string;
};

export type SearchUsersRole = typeof SearchUsersRole[keyof typeof SearchUsersRole];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SearchUsersRole = {
  STUDENT: 'STUDENT',
  TEACHER: 'TEACHER',
  PRINCIPAL: 'PRINCIPAL',
  ADMIN: 'ADMIN',
} as const;

export type GetAvailableStudentsForLectureParams = {
name: string;
};

export type SubmitAssignmentParams = {
studentId: number;
};

export type SubmitAssignmentParams = {
studentId: number;
};

export type GetWeakUnitsParams = {
limit?: number;
};

export type GetMonthlyAttendanceParams = {
year: number;
/**
 * @minimum 1
 * @maximum 12
 */
month: number;
};

/**
 * @summary ÏÇ¨Ïö©Ïûê Î°úÍ∑∏Ïù∏
 */
export const signIn = (
    signInRequest: SignInRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SignInResponse>> => {
    
    
    return axios.default.post(
      `/api/users/signin`,
      signInRequest,options
    );
  }



export const getSignInMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof signIn>>, TError,{data: SignInRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof signIn>>, TError,{data: SignInRequest}, TContext> => {

const mutationKey = ['signIn'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof signIn>>, {data: SignInRequest}> = (props) => {
          const {data} = props ?? {};

          return  signIn(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SignInMutationResult = NonNullable<Awaited<ReturnType<typeof signIn>>>
    export type SignInMutationBody = SignInRequest
    export type SignInMutationError = AxiosError<unknown>

    /**
 * @summary ÏÇ¨Ïö©Ïûê Î°úÍ∑∏Ïù∏
 */
export const useSignIn = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof signIn>>, TError,{data: SignInRequest}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof signIn>>,
        TError,
        {data: SignInRequest},
        TContext
      > => {

      const mutationOptions = getSignInMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary ÏÇ¨Ïö©Ïûê Î°úÍ∑∏ÏïÑÏõÉ
 */
export const logout = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.post(
      `/api/users/logout`,undefined,options
    );
  }



export const getLogoutMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError,void, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError,void, TContext> => {

const mutationKey = ['logout'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof logout>>, void> = () => {
          

          return  logout(axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LogoutMutationResult = NonNullable<Awaited<ReturnType<typeof logout>>>
    
    export type LogoutMutationError = AxiosError<unknown>

    /**
 * @summary ÏÇ¨Ïö©Ïûê Î°úÍ∑∏ÏïÑÏõÉ
 */
export const useLogout = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError,void, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof logout>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getLogoutMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary ÎÇ¥ Ï†ïÎ≥¥ Ï°∞Ìöå
 */
export const getMyInfo = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MyInfoResponse>> => {
    
    
    return axios.default.get(
      `/api/users/me`,options
    );
  }




export const getGetMyInfoQueryKey = () => {
    return [
    `/api/users/me`
    ] as const;
    }

    
export const getGetMyInfoQueryOptions = <TData = Awaited<ReturnType<typeof getMyInfo>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMyInfo>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMyInfoQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyInfo>>> = ({ signal }) => getMyInfo({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMyInfo>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMyInfoQueryResult = NonNullable<Awaited<ReturnType<typeof getMyInfo>>>
export type GetMyInfoQueryError = AxiosError<unknown>


/**
 * @summary ÎÇ¥ Ï†ïÎ≥¥ Ï°∞Ìöå
 */

export function useGetMyInfo<TData = Awaited<ReturnType<typeof getMyInfo>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMyInfo>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetMyInfoQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary ÌöåÏõêÍ∞ÄÏûÖ
 */
export const signup = (
    signupRequest: SignupRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    
    
    return axios.default.post(
      `/api/auth/signup`,
      signupRequest,{
    ...options,}
    );
  }



export const getSignupMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof signup>>, TError,{data: SignupRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof signup>>, TError,{data: SignupRequest}, TContext> => {

const mutationKey = ['signup'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof signup>>, {data: SignupRequest}> = (props) => {
          const {data} = props ?? {};

          return  signup(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SignupMutationResult = NonNullable<Awaited<ReturnType<typeof signup>>>
    export type SignupMutationBody = SignupRequest
    export type SignupMutationError = AxiosError<unknown>

    /**
 * @summary ÌöåÏõêÍ∞ÄÏûÖ
 */
export const useSignup = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof signup>>, TError,{data: SignupRequest}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof signup>>,
        TError,
        {data: SignupRequest},
        TContext
      > => {

      const mutationOptions = getSignupMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Ïù¥Î©îÏùº Ïù∏Ï¶ù ÏΩîÎìú Î∞úÏÜ°
 */
export const sendEmailVerification = (
    sendEmailVerificationRequest: SendEmailVerificationRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    
    
    return axios.default.post(
      `/api/auth/send-email-verification`,
      sendEmailVerificationRequest,{
    ...options,}
    );
  }



export const getSendEmailVerificationMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sendEmailVerification>>, TError,{data: SendEmailVerificationRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof sendEmailVerification>>, TError,{data: SendEmailVerificationRequest}, TContext> => {

const mutationKey = ['sendEmailVerification'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sendEmailVerification>>, {data: SendEmailVerificationRequest}> = (props) => {
          const {data} = props ?? {};

          return  sendEmailVerification(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SendEmailVerificationMutationResult = NonNullable<Awaited<ReturnType<typeof sendEmailVerification>>>
    export type SendEmailVerificationMutationBody = SendEmailVerificationRequest
    export type SendEmailVerificationMutationError = AxiosError<unknown>

    /**
 * @summary Ïù¥Î©îÏùº Ïù∏Ï¶ù ÏΩîÎìú Î∞úÏÜ°
 */
export const useSendEmailVerification = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sendEmailVerification>>, TError,{data: SendEmailVerificationRequest}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof sendEmailVerification>>,
        TError,
        {data: SendEmailVerificationRequest},
        TContext
      > => {

      const mutationOptions = getSendEmailVerificationMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Ïù¥Î©îÏùº Ïù∏Ï¶ù ÌôïÏù∏
 */
export const verifyEmail = (
    verifyEmailRequest: VerifyEmailRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    
    
    return axios.default.post(
      `/api/auth/verify-email`,
      verifyEmailRequest,{
    ...options,}
    );
  }



export const getVerifyEmailMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof verifyEmail>>, TError,{data: VerifyEmailRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof verifyEmail>>, TError,{data: VerifyEmailRequest}, TContext> => {

const mutationKey = ['verifyEmail'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof verifyEmail>>, {data: VerifyEmailRequest}> = (props) => {
          const {data} = props ?? {};

          return  verifyEmail(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type VerifyEmailMutationResult = NonNullable<Awaited<ReturnType<typeof verifyEmail>>>
    export type VerifyEmailMutationBody = VerifyEmailRequest
    export type VerifyEmailMutationError = AxiosError<unknown>

    /**
 * @summary Ïù¥Î©îÏùº Ïù∏Ï¶ù ÌôïÏù∏
 */
export const useVerifyEmail = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof verifyEmail>>, TError,{data: VerifyEmailRequest}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof verifyEmail>>,
        TError,
        {data: VerifyEmailRequest},
        TContext
      > => {

      const mutationOptions = getVerifyEmailMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary ÏµúÏ¢Ö ÌöåÏõêÍ∞ÄÏûÖ ÏôÑÎ£å
 */
export const completeSignup = (
    verifyEmailRequest: VerifyEmailRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SignupResponse>> => {
    
    
    return axios.default.post(
      `/api/auth/signup/complete`,
      verifyEmailRequest,options
    );
  }



export const getCompleteSignupMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof completeSignup>>, TError,{data: VerifyEmailRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof completeSignup>>, TError,{data: VerifyEmailRequest}, TContext> => {

const mutationKey = ['completeSignup'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof completeSignup>>, {data: VerifyEmailRequest}> = (props) => {
          const {data} = props ?? {};

          return  completeSignup(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CompleteSignupMutationResult = NonNullable<Awaited<ReturnType<typeof completeSignup>>>
    export type CompleteSignupMutationBody = VerifyEmailRequest
    export type CompleteSignupMutationError = AxiosError<unknown>

    /**
 * @summary ÏµúÏ¢Ö ÌöåÏõêÍ∞ÄÏûÖ ÏôÑÎ£å
 */
export const useCompleteSignup = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof completeSignup>>, TError,{data: VerifyEmailRequest}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof completeSignup>>,
        TError,
        {data: VerifyEmailRequest},
        TContext
      > => {

      const mutationOptions = getCompleteSignupMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary ÌïôÏÉù Í∞úÏù∏ + ÌäπÏ†ï ÏãúÌóò Î¨∏Ìï≠Î≥Ñ Ï†ïÎãµÎ•† Ï°∞Ìöå
 */
export const getStudentQuestionStatistics = (
    examId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<StudentQuestionStatisticsResponse[]>> => {
    
    
    return axios.default.get(
      `/api/student/statistics/exams/${examId}/questions`,options
    );
  }




export const getGetStudentQuestionStatisticsQueryKey = (examId?: number,) => {
    return [
    `/api/student/statistics/exams/${examId}/questions`
    ] as const;
    }

    
export const getGetStudentQuestionStatisticsQueryOptions = <TData = Awaited<ReturnType<typeof getStudentQuestionStatistics>>, TError = AxiosError<unknown>>(examId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getStudentQuestionStatistics>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStudentQuestionStatisticsQueryKey(examId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStudentQuestionStatistics>>> = ({ signal }) => getStudentQuestionStatistics(examId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(examId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getStudentQuestionStatistics>>, TError, TData> & { queryKey: QueryKey }
}

export type GetStudentQuestionStatisticsQueryResult = NonNullable<Awaited<ReturnType<typeof getStudentQuestionStatistics>>>
export type GetStudentQuestionStatisticsQueryError = AxiosError<unknown>


/**
 * @summary ÌïôÏÉù Í∞úÏù∏ + ÌäπÏ†ï ÏãúÌóò Î¨∏Ìï≠Î≥Ñ Ï†ïÎãµÎ•† Ï°∞Ìöå
 */

export function useGetStudentQuestionStatistics<TData = Awaited<ReturnType<typeof getStudentQuestionStatistics>>, TError = AxiosError<unknown>>(
 examId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getStudentQuestionStatistics>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetStudentQuestionStatisticsQueryOptions(examId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Í∞ïÏÇ¨Ïö©: ÌäπÏ†ï ÏãúÌóò Î¨∏Ìï≠Î≥Ñ Ï†ïÎãµÎ•†
 */
export const getExamQuestionCorrectRates = (
    examId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<QuestionCorrectRateResponse[]>> => {
    
    
    return axios.default.get(
      `/api/statistics/exams/${examId}/questions`,options
    );
  }




export const getGetExamQuestionCorrectRatesQueryKey = (examId?: number,) => {
    return [
    `/api/statistics/exams/${examId}/questions`
    ] as const;
    }

    
export const getGetExamQuestionCorrectRatesQueryOptions = <TData = Awaited<ReturnType<typeof getExamQuestionCorrectRates>>, TError = AxiosError<unknown>>(examId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getExamQuestionCorrectRates>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetExamQuestionCorrectRatesQueryKey(examId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getExamQuestionCorrectRates>>> = ({ signal }) => getExamQuestionCorrectRates(examId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(examId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getExamQuestionCorrectRates>>, TError, TData> & { queryKey: QueryKey }
}

export type GetExamQuestionCorrectRatesQueryResult = NonNullable<Awaited<ReturnType<typeof getExamQuestionCorrectRates>>>
export type GetExamQuestionCorrectRatesQueryError = AxiosError<unknown>


/**
 * @summary Í∞ïÏÇ¨Ïö©: ÌäπÏ†ï ÏãúÌóò Î¨∏Ìï≠Î≥Ñ Ï†ïÎãµÎ•†
 */

export function useGetExamQuestionCorrectRates<TData = Awaited<ReturnType<typeof getExamQuestionCorrectRates>>, TError = AxiosError<unknown>>(
 examId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getExamQuestionCorrectRates>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetExamQuestionCorrectRatesQueryOptions(examId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Í∞ïÏÇ¨Ïö©: Í∞ïÏùò Ï†ÑÏ≤¥ Î¨∏Ìï≠Î≥Ñ Ï†ïÎãµÎ•†
 */
export const getLectureQuestionCorrectRates = (
    lectureId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<QuestionCorrectRateResponse[]>> => {
    
    
    return axios.default.get(
      `/api/statistics/lectures/${lectureId}/questions`,options
    );
  }




export const getGetLectureQuestionCorrectRatesQueryKey = (lectureId?: number,) => {
    return [
    `/api/statistics/lectures/${lectureId}/questions`
    ] as const;
    }

    
export const getGetLectureQuestionCorrectRatesQueryOptions = <TData = Awaited<ReturnType<typeof getLectureQuestionCorrectRates>>, TError = AxiosError<unknown>>(lectureId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getLectureQuestionCorrectRates>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetLectureQuestionCorrectRatesQueryKey(lectureId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getLectureQuestionCorrectRates>>> = ({ signal }) => getLectureQuestionCorrectRates(lectureId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(lectureId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getLectureQuestionCorrectRates>>, TError, TData> & { queryKey: QueryKey }
}

export type GetLectureQuestionCorrectRatesQueryResult = NonNullable<Awaited<ReturnType<typeof getLectureQuestionCorrectRates>>>
export type GetLectureQuestionCorrectRatesQueryError = AxiosError<unknown>


/**
 * @summary Í∞ïÏÇ¨Ïö©: Í∞ïÏùò Ï†ÑÏ≤¥ Î¨∏Ìï≠Î≥Ñ Ï†ïÎãµÎ•†
 */

export function useGetLectureQuestionCorrectRates<TData = Awaited<ReturnType<typeof getLectureQuestionCorrectRates>>, TError = AxiosError<unknown>>(
 lectureId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getLectureQuestionCorrectRates>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetLectureQuestionCorrectRatesQueryOptions(lectureId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary ÏÇ¨Ïö©Ïûê Í≤ÄÏÉâ
 */
export const searchUsers = (
    academyId: number,
    params?: SearchUsersParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserSearchResultResponse[]>> => {
    
    
    return axios.default.get(
      `/api/academies/${academyId}/users/search`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getSearchUsersQueryKey = (academyId?: number,
    params?: SearchUsersParams,) => {
    return [
    `/api/academies/${academyId}/users/search`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getSearchUsersQueryOptions = <TData = Awaited<ReturnType<typeof searchUsers>>, TError = AxiosError<unknown>>(academyId: number,
    params?: SearchUsersParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof searchUsers>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchUsersQueryKey(academyId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchUsers>>> = ({ signal }) => searchUsers(academyId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(academyId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof searchUsers>>, TError, TData> & { queryKey: QueryKey }
}

export type SearchUsersQueryResult = NonNullable<Awaited<ReturnType<typeof searchUsers>>>
export type SearchUsersQueryError = AxiosError<unknown>


/**
 * @summary ÏÇ¨Ïö©Ïûê Í≤ÄÏÉâ
 */

export function useSearchUsers<TData = Awaited<ReturnType<typeof searchUsers>>, TError = AxiosError<unknown>>(
 academyId: number,
    params?: SearchUsersParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof searchUsers>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getSearchUsersQueryOptions(academyId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary ÌïôÏÉùÏùÑ Í∞ïÏÇ¨Î°ú Ïó≠Ìï† Î≥ÄÍ≤Ω
 */
export const changeStudentToTeacher = (
    academyId: number,
    userId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    
    
    return axios.default.patch(
      `/api/academies/${academyId}/users/${userId}/role/teacher`,undefined,{
    ...options,}
    );
  }



export const getChangeStudentToTeacherMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof changeStudentToTeacher>>, TError,{academyId: number;userId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof changeStudentToTeacher>>, TError,{academyId: number;userId: number}, TContext> => {

const mutationKey = ['changeStudentToTeacher'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof changeStudentToTeacher>>, {academyId: number;userId: number}> = (props) => {
          const {academyId,userId} = props ?? {};

          return  changeStudentToTeacher(academyId,userId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ChangeStudentToTeacherMutationResult = NonNullable<Awaited<ReturnType<typeof changeStudentToTeacher>>>
    
    export type ChangeStudentToTeacherMutationError = AxiosError<unknown>

    /**
 * @summary ÌïôÏÉùÏùÑ Í∞ïÏÇ¨Î°ú Ïó≠Ìï† Î≥ÄÍ≤Ω
 */
export const useChangeStudentToTeacher = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof changeStudentToTeacher>>, TError,{academyId: number;userId: number}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof changeStudentToTeacher>>,
        TError,
        {academyId: number;userId: number},
        TContext
      > => {

      const mutationOptions = getChangeStudentToTeacherMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary ÏõêÏû•(ÌïôÏõê) ÌöåÏõêÍ∞ÄÏûÖ
 */
export const principalSignup = (
    principalRegistrationRequest: PrincipalRegistrationRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PrincipalRegistrationResponse>> => {
    
    
    return axios.default.post(
      `/api/academy/signup`,
      principalRegistrationRequest,options
    );
  }



export const getPrincipalSignupMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof principalSignup>>, TError,{data: PrincipalRegistrationRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof principalSignup>>, TError,{data: PrincipalRegistrationRequest}, TContext> => {

const mutationKey = ['principalSignup'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof principalSignup>>, {data: PrincipalRegistrationRequest}> = (props) => {
          const {data} = props ?? {};

          return  principalSignup(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PrincipalSignupMutationResult = NonNullable<Awaited<ReturnType<typeof principalSignup>>>
    export type PrincipalSignupMutationBody = PrincipalRegistrationRequest
    export type PrincipalSignupMutationError = AxiosError<unknown>

    /**
 * @summary ÏõêÏû•(ÌïôÏõê) ÌöåÏõêÍ∞ÄÏûÖ
 */
export const usePrincipalSignup = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof principalSignup>>, TError,{data: PrincipalRegistrationRequest}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof principalSignup>>,
        TError,
        {data: PrincipalRegistrationRequest},
        TContext
      > => {

      const mutationOptions = getPrincipalSignupMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Í∞ïÏùò ÏÉùÏÑ±
 */
export const createLecture = (
    lectureCreationRequest: LectureCreationRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<LectureCreationResponse>> => {
    
    
    return axios.default.post(
      `/api/lectures`,
      lectureCreationRequest,options
    );
  }



export const getCreateLectureMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createLecture>>, TError,{data: LectureCreationRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createLecture>>, TError,{data: LectureCreationRequest}, TContext> => {

const mutationKey = ['createLecture'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createLecture>>, {data: LectureCreationRequest}> = (props) => {
          const {data} = props ?? {};

          return  createLecture(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateLectureMutationResult = NonNullable<Awaited<ReturnType<typeof createLecture>>>
    export type CreateLectureMutationBody = LectureCreationRequest
    export type CreateLectureMutationError = AxiosError<unknown>

    /**
 * @summary Í∞ïÏùò ÏÉùÏÑ±
 */
export const useCreateLecture = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createLecture>>, TError,{data: LectureCreationRequest}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof createLecture>>,
        TError,
        {data: LectureCreationRequest},
        TContext
      > => {

      const mutationOptions = getCreateLectureMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Í∞ïÏùò Î™©Î°ù Ï°∞Ìöå (ÏÑ†ÏÉù/ÏõêÏû•)
 */
export const getLecturesByTeacher = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<LectureForTeacherResponse[]>> => {
    
    
    return axios.default.get(
      `/api/lectures`,options
    );
  }




export const getGetLecturesByTeacherQueryKey = () => {
    return [
    `/api/lectures`
    ] as const;
    }

    
export const getGetLecturesByTeacherQueryOptions = <TData = Awaited<ReturnType<typeof getLecturesByTeacher>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getLecturesByTeacher>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetLecturesByTeacherQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getLecturesByTeacher>>> = ({ signal }) => getLecturesByTeacher({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getLecturesByTeacher>>, TError, TData> & { queryKey: QueryKey }
}

export type GetLecturesByTeacherQueryResult = NonNullable<Awaited<ReturnType<typeof getLecturesByTeacher>>>
export type GetLecturesByTeacherQueryError = AxiosError<unknown>


/**
 * @summary Í∞ïÏùò Î™©Î°ù Ï°∞Ìöå (ÏÑ†ÏÉù/ÏõêÏû•)
 */

export function useGetLecturesByTeacher<TData = Awaited<ReturnType<typeof getLecturesByTeacher>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getLecturesByTeacher>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetLecturesByTeacherQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Í∞ïÏùò ÏÉÅÏÑ∏ Ï°∞Ìöå (ÏÑ†ÏÉù/ÏõêÏû•) - ÌÜµÍ≥Ñ Ìè¨Ìï®
 */
export const getLectureDetailForTeacher = (
    lectureId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<LectureDetailWithStatisticsResponse>> => {
    
    
    return axios.default.get(
      `/api/lectures/${lectureId}`,options
    );
  }




export const getGetLectureDetailForTeacherQueryKey = (lectureId?: number,) => {
    return [
    `/api/lectures/${lectureId}`
    ] as const;
    }

    
export const getGetLectureDetailForTeacherQueryOptions = <TData = Awaited<ReturnType<typeof getLectureDetailForTeacher>>, TError = AxiosError<unknown>>(lectureId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getLectureDetailForTeacher>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetLectureDetailForTeacherQueryKey(lectureId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getLectureDetailForTeacher>>> = ({ signal }) => getLectureDetailForTeacher(lectureId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(lectureId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getLectureDetailForTeacher>>, TError, TData> & { queryKey: QueryKey }
}

export type GetLectureDetailForTeacherQueryResult = NonNullable<Awaited<ReturnType<typeof getLectureDetailForTeacher>>>
export type GetLectureDetailForTeacherQueryError = AxiosError<unknown>


/**
 * @summary Í∞ïÏùò ÏÉÅÏÑ∏ Ï°∞Ìöå (ÏÑ†ÏÉù/ÏõêÏû•) - ÌÜµÍ≥Ñ Ìè¨Ìï®
 */

export function useGetLectureDetailForTeacher<TData = Awaited<ReturnType<typeof getLectureDetailForTeacher>>, TError = AxiosError<unknown>>(
 lectureId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getLectureDetailForTeacher>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetLectureDetailForTeacherQueryOptions(lectureId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Í∞ïÏùòÎ•º Îì£Îäî ÌïôÏÉù Î™©Î°ù Ï°∞Ìöå
 */
export const getStudentsByLecture = (
    lectureId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<StudentSearchResponse[]>> => {
    
    
    return axios.default.get(
      `/api/lectures/${lectureId}/students`,options
    );
  }




export const getGetStudentsByLectureQueryKey = (lectureId?: number,) => {
    return [
    `/api/lectures/${lectureId}/students`
    ] as const;
    }

    
export const getGetStudentsByLectureQueryOptions = <TData = Awaited<ReturnType<typeof getStudentsByLecture>>, TError = AxiosError<unknown>>(lectureId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getStudentsByLecture>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStudentsByLectureQueryKey(lectureId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStudentsByLecture>>> = ({ signal }) => getStudentsByLecture(lectureId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(lectureId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getStudentsByLecture>>, TError, TData> & { queryKey: QueryKey }
}

export type GetStudentsByLectureQueryResult = NonNullable<Awaited<ReturnType<typeof getStudentsByLecture>>>
export type GetStudentsByLectureQueryError = AxiosError<unknown>


/**
 * @summary Í∞ïÏùòÎ•º Îì£Îäî ÌïôÏÉù Î™©Î°ù Ï°∞Ìöå
 */

export function useGetStudentsByLecture<TData = Awaited<ReturnType<typeof getStudentsByLecture>>, TError = AxiosError<unknown>>(
 lectureId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getStudentsByLecture>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetStudentsByLectureQueryOptions(lectureId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Í∞ïÏùòÏóê ÌïôÏÉù Î∞∞Ï†ï
 */
export const assignStudentsToLecture = (
    lectureId: number,
    lectureStudentAssignRequest: LectureStudentAssignRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<LectureStudentAssignResponse>> => {
    
    
    return axios.default.post(
      `/api/lectures/${lectureId}/students`,
      lectureStudentAssignRequest,options
    );
  }



export const getAssignStudentsToLectureMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof assignStudentsToLecture>>, TError,{lectureId: number;data: LectureStudentAssignRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof assignStudentsToLecture>>, TError,{lectureId: number;data: LectureStudentAssignRequest}, TContext> => {

const mutationKey = ['assignStudentsToLecture'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof assignStudentsToLecture>>, {lectureId: number;data: LectureStudentAssignRequest}> = (props) => {
          const {lectureId,data} = props ?? {};

          return  assignStudentsToLecture(lectureId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AssignStudentsToLectureMutationResult = NonNullable<Awaited<ReturnType<typeof assignStudentsToLecture>>>
    export type AssignStudentsToLectureMutationBody = LectureStudentAssignRequest
    export type AssignStudentsToLectureMutationError = AxiosError<unknown>

    /**
 * @summary Í∞ïÏùòÏóê ÌïôÏÉù Î∞∞Ï†ï
 */
export const useAssignStudentsToLecture = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof assignStudentsToLecture>>, TError,{lectureId: number;data: LectureStudentAssignRequest}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof assignStudentsToLecture>>,
        TError,
        {lectureId: number;data: LectureStudentAssignRequest},
        TContext
      > => {

      const mutationOptions = getAssignStudentsToLectureMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Í∞ïÏùòÏóê Î∞∞Ï†ïÎêòÏßÄ ÏïäÏùÄ ÌïôÏÉù Í≤ÄÏÉâ
 */
export const getAvailableStudentsForLecture = (
    lectureId: number,
    params: GetAvailableStudentsForLectureParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<StudentSearchResponse[]>> => {
    
    
    return axios.default.get(
      `/api/lectures/${lectureId}/available-students`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getGetAvailableStudentsForLectureQueryKey = (lectureId?: number,
    params?: GetAvailableStudentsForLectureParams,) => {
    return [
    `/api/lectures/${lectureId}/available-students`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetAvailableStudentsForLectureQueryOptions = <TData = Awaited<ReturnType<typeof getAvailableStudentsForLecture>>, TError = AxiosError<unknown>>(lectureId: number,
    params: GetAvailableStudentsForLectureParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAvailableStudentsForLecture>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAvailableStudentsForLectureQueryKey(lectureId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAvailableStudentsForLecture>>> = ({ signal }) => getAvailableStudentsForLecture(lectureId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(lectureId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAvailableStudentsForLecture>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAvailableStudentsForLectureQueryResult = NonNullable<Awaited<ReturnType<typeof getAvailableStudentsForLecture>>>
export type GetAvailableStudentsForLectureQueryError = AxiosError<unknown>


/**
 * @summary Í∞ïÏùòÏóê Î∞∞Ï†ïÎêòÏßÄ ÏïäÏùÄ ÌïôÏÉù Í≤ÄÏÉâ
 */

export function useGetAvailableStudentsForLecture<TData = Awaited<ReturnType<typeof getAvailableStudentsForLecture>>, TError = AxiosError<unknown>>(
 lectureId: number,
    params: GetAvailableStudentsForLectureParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAvailableStudentsForLecture>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAvailableStudentsForLectureQueryOptions(lectureId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Í≥ºÏ†ú ÏÉùÏÑ±
 */
export const createAssignment = (
    academyId: number,
    assignmentCreateRequest: AssignmentCreateRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AssignmentCreateResponse>> => {
    
    
    return axios.default.post(
      `/api/academies/${academyId}/assignments`,
      assignmentCreateRequest,options
    );
  }



export const getCreateAssignmentMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAssignment>>, TError,{academyId: number;data: AssignmentCreateRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createAssignment>>, TError,{academyId: number;data: AssignmentCreateRequest}, TContext> => {

const mutationKey = ['createAssignment'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createAssignment>>, {academyId: number;data: AssignmentCreateRequest}> = (props) => {
          const {academyId,data} = props ?? {};

          return  createAssignment(academyId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateAssignmentMutationResult = NonNullable<Awaited<ReturnType<typeof createAssignment>>>
    export type CreateAssignmentMutationBody = AssignmentCreateRequest
    export type CreateAssignmentMutationError = AxiosError<unknown>

    /**
 * @summary Í≥ºÏ†ú ÏÉùÏÑ±
 */
export const useCreateAssignment = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAssignment>>, TError,{academyId: number;data: AssignmentCreateRequest}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof createAssignment>>,
        TError,
        {academyId: number;data: AssignmentCreateRequest},
        TContext
      > => {

      const mutationOptions = getCreateAssignmentMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary ÌïôÏÉùÏö© - ÌäπÏ†ï Í∞ïÏùòÏùò Í≥ºÏ†ú Î¶¨Ïä§Ìä∏ Ï°∞Ìöå
 */
export const getAssignmentsForLecture = (
    academyId: number,
    lectureId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AssignmentListResponse[]>> => {
    
    
    return axios.default.get(
      `/api/academies/${academyId}/assignments/lectures/${lectureId}`,options
    );
  }




export const getGetAssignmentsForLectureQueryKey = (academyId?: number,
    lectureId?: number,) => {
    return [
    `/api/academies/${academyId}/assignments/lectures/${lectureId}`
    ] as const;
    }

    
export const getGetAssignmentsForLectureQueryOptions = <TData = Awaited<ReturnType<typeof getAssignmentsForLecture>>, TError = AxiosError<unknown>>(academyId: number,
    lectureId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssignmentsForLecture>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssignmentsForLectureQueryKey(academyId,lectureId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssignmentsForLecture>>> = ({ signal }) => getAssignmentsForLecture(academyId,lectureId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(academyId && lectureId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAssignmentsForLecture>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAssignmentsForLectureQueryResult = NonNullable<Awaited<ReturnType<typeof getAssignmentsForLecture>>>
export type GetAssignmentsForLectureQueryError = AxiosError<unknown>


/**
 * @summary ÌïôÏÉùÏö© - ÌäπÏ†ï Í∞ïÏùòÏùò Í≥ºÏ†ú Î¶¨Ïä§Ìä∏ Ï°∞Ìöå
 */

export function useGetAssignmentsForLecture<TData = Awaited<ReturnType<typeof getAssignmentsForLecture>>, TError = AxiosError<unknown>>(
 academyId: number,
    lectureId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssignmentsForLecture>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAssignmentsForLectureQueryOptions(academyId,lectureId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary ÌïôÏÉùÏö© - ÏûêÏã†Ïùò Í≥ºÏ†ú Ï†úÏ∂ú ÏÉÅÏÑ∏ Ï°∞Ìöå
 */
export const getMySubmission = (
    academyId: number,
    assignmentId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AssignmentSubmissionStudentViewResponse>> => {
    
    
    return axios.default.get(
      `/api/academies/${academyId}/assignments/${assignmentId}/my-submission`,options
    );
  }




export const getGetMySubmissionQueryKey = (academyId?: number,
    assignmentId?: number,) => {
    return [
    `/api/academies/${academyId}/assignments/${assignmentId}/my-submission`
    ] as const;
    }

    
export const getGetMySubmissionQueryOptions = <TData = Awaited<ReturnType<typeof getMySubmission>>, TError = AxiosError<unknown>>(academyId: number,
    assignmentId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMySubmission>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMySubmissionQueryKey(academyId,assignmentId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMySubmission>>> = ({ signal }) => getMySubmission(academyId,assignmentId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(academyId && assignmentId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMySubmission>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMySubmissionQueryResult = NonNullable<Awaited<ReturnType<typeof getMySubmission>>>
export type GetMySubmissionQueryError = AxiosError<unknown>


/**
 * @summary ÌïôÏÉùÏö© - ÏûêÏã†Ïùò Í≥ºÏ†ú Ï†úÏ∂ú ÏÉÅÏÑ∏ Ï°∞Ìöå
 */

export function useGetMySubmission<TData = Awaited<ReturnType<typeof getMySubmission>>, TError = AxiosError<unknown>>(
 academyId: number,
    assignmentId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMySubmission>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetMySubmissionQueryOptions(academyId,assignmentId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Í≥ºÏ†ú Ï†úÏ∂úÏö© Presigned URL Î∞úÍ∏â
 */
export const getAssignmentPresignedUrl = (
    assignmentId: number,
    presignedUrlRequest: PresignedUrlRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PresignedUrlResponse>> => {
    
    
    return axios.default.post(
      `/api/assignments/${assignmentId}/presigned-url`,
      presignedUrlRequest,options
    );
  }



export const getGetAssignmentPresignedUrlMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getAssignmentPresignedUrl>>, TError,{assignmentId: number;data: PresignedUrlRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof getAssignmentPresignedUrl>>, TError,{assignmentId: number;data: PresignedUrlRequest}, TContext> => {

const mutationKey = ['getAssignmentPresignedUrl'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof getAssignmentPresignedUrl>>, {assignmentId: number;data: PresignedUrlRequest}> = (props) => {
          const {assignmentId,data} = props ?? {};

          return  getAssignmentPresignedUrl(assignmentId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GetAssignmentPresignedUrlMutationResult = NonNullable<Awaited<ReturnType<typeof getAssignmentPresignedUrl>>>
    export type GetAssignmentPresignedUrlMutationBody = PresignedUrlRequest
    export type GetAssignmentPresignedUrlMutationError = AxiosError<unknown>

    /**
 * @summary Í≥ºÏ†ú Ï†úÏ∂úÏö© Presigned URL Î∞úÍ∏â
 */
export const useGetAssignmentPresignedUrl = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getAssignmentPresignedUrl>>, TError,{assignmentId: number;data: PresignedUrlRequest}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof getAssignmentPresignedUrl>>,
        TError,
        {assignmentId: number;data: PresignedUrlRequest},
        TContext
      > => {

      const mutationOptions = getGetAssignmentPresignedUrlMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Í≥ºÏ†ú Ï†úÏ∂ú
 */
export const submitAssignment = (
    assignmentId: number,
    assignmentSubmitRequest: AssignmentSubmitRequest,
    params: SubmitAssignmentParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AssignmentSubmitResponse>> => {
    
    
    return axios.default.post(
      `/api/assignments/${assignmentId}/submit`,
      assignmentSubmitRequest,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getSubmitAssignmentMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof submitAssignment>>, TError,{assignmentId: number;data: AssignmentSubmitRequest;params: SubmitAssignmentParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof submitAssignment>>, TError,{assignmentId: number;data: AssignmentSubmitRequest;params: SubmitAssignmentParams}, TContext> => {

const mutationKey = ['submitAssignment'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof submitAssignment>>, {assignmentId: number;data: AssignmentSubmitRequest;params: SubmitAssignmentParams}> = (props) => {
          const {assignmentId,data,params} = props ?? {};

          return  submitAssignment(assignmentId,data,params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SubmitAssignmentMutationResult = NonNullable<Awaited<ReturnType<typeof submitAssignment>>>
    export type SubmitAssignmentMutationBody = AssignmentSubmitRequest
    export type SubmitAssignmentMutationError = AxiosError<unknown>

    /**
 * @summary Í≥ºÏ†ú Ï†úÏ∂ú
 */
export const useSubmitAssignment = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof submitAssignment>>, TError,{assignmentId: number;data: AssignmentSubmitRequest;params: SubmitAssignmentParams}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof submitAssignment>>,
        TError,
        {assignmentId: number;data: AssignmentSubmitRequest;params: SubmitAssignmentParams},
        TContext
      > => {

      const mutationOptions = getSubmitAssignmentMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Í∞ïÏÇ¨Ïö© - ÌäπÏ†ï Í≥ºÏ†ú Ï†úÏ∂ú Î¶¨Ïä§Ìä∏ Ï°∞Ìöå
 */
export const getSubmissions = (
    academyId: number,
    assignmentId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AssignmentSubmissionListResponse[]>> => {
    
    
    return axios.default.get(
      `/api/academies/${academyId}/assignments/${assignmentId}/submissions`,options
    );
  }




export const getGetSubmissionsQueryKey = (academyId?: number,
    assignmentId?: number,) => {
    return [
    `/api/academies/${academyId}/assignments/${assignmentId}/submissions`
    ] as const;
    }

    
export const getGetSubmissionsQueryOptions = <TData = Awaited<ReturnType<typeof getSubmissions>>, TError = AxiosError<unknown>>(academyId: number,
    assignmentId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getSubmissions>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSubmissionsQueryKey(academyId,assignmentId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSubmissions>>> = ({ signal }) => getSubmissions(academyId,assignmentId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(academyId && assignmentId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSubmissions>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSubmissionsQueryResult = NonNullable<Awaited<ReturnType<typeof getSubmissions>>>
export type GetSubmissionsQueryError = AxiosError<unknown>


/**
 * @summary Í∞ïÏÇ¨Ïö© - ÌäπÏ†ï Í≥ºÏ†ú Ï†úÏ∂ú Î¶¨Ïä§Ìä∏ Ï°∞Ìöå
 */

export function useGetSubmissions<TData = Awaited<ReturnType<typeof getSubmissions>>, TError = AxiosError<unknown>>(
 academyId: number,
    assignmentId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getSubmissions>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetSubmissionsQueryOptions(academyId,assignmentId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Í∞ïÏÇ¨Ïö© - Í≥ºÏ†ú Ï†úÏ∂ú ÏÉÅÏÑ∏ Ï°∞Ìöå
 */
export const getSubmissionForTeacher = (
    academyId: number,
    assignmentId: number,
    submissionId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AssignmentSubmissionTeacherViewResponse>> => {
    
    
    return axios.default.get(
      `/api/academies/${academyId}/assignments/${assignmentId}/submissions/${submissionId}`,options
    );
  }




export const getGetSubmissionForTeacherQueryKey = (academyId?: number,
    assignmentId?: number,
    submissionId?: number,) => {
    return [
    `/api/academies/${academyId}/assignments/${assignmentId}/submissions/${submissionId}`
    ] as const;
    }

    
export const getGetSubmissionForTeacherQueryOptions = <TData = Awaited<ReturnType<typeof getSubmissionForTeacher>>, TError = AxiosError<unknown>>(academyId: number,
    assignmentId: number,
    submissionId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getSubmissionForTeacher>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSubmissionForTeacherQueryKey(academyId,assignmentId,submissionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSubmissionForTeacher>>> = ({ signal }) => getSubmissionForTeacher(academyId,assignmentId,submissionId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(academyId && assignmentId && submissionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSubmissionForTeacher>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSubmissionForTeacherQueryResult = NonNullable<Awaited<ReturnType<typeof getSubmissionForTeacher>>>
export type GetSubmissionForTeacherQueryError = AxiosError<unknown>


/**
 * @summary Í∞ïÏÇ¨Ïö© - Í≥ºÏ†ú Ï†úÏ∂ú ÏÉÅÏÑ∏ Ï°∞Ìöå
 */

export function useGetSubmissionForTeacher<TData = Awaited<ReturnType<typeof getSubmissionForTeacher>>, TError = AxiosError<unknown>>(
 academyId: number,
    assignmentId: number,
    submissionId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getSubmissionForTeacher>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetSubmissionForTeacherQueryOptions(academyId,assignmentId,submissionId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Í∞ïÏÇ¨Ïö© - Ï†êÏàò Î∞è ÌîºÎìúÎ∞± Ï†ÄÏû•
 */
export const gradeSubmission = (
    academyId: number,
    assignmentId: number,
    submissionId: number,
    assignmentGradeRequest: AssignmentGradeRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AssignmentGradeResponse>> => {
    
    
    return axios.default.patch(
      `/api/academies/${academyId}/assignments/${assignmentId}/submissions/${submissionId}/grade`,
      assignmentGradeRequest,options
    );
  }



export const getGradeSubmissionMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof gradeSubmission>>, TError,{academyId: number;assignmentId: number;submissionId: number;data: AssignmentGradeRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof gradeSubmission>>, TError,{academyId: number;assignmentId: number;submissionId: number;data: AssignmentGradeRequest}, TContext> => {

const mutationKey = ['gradeSubmission'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof gradeSubmission>>, {academyId: number;assignmentId: number;submissionId: number;data: AssignmentGradeRequest}> = (props) => {
          const {academyId,assignmentId,submissionId,data} = props ?? {};

          return  gradeSubmission(academyId,assignmentId,submissionId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GradeSubmissionMutationResult = NonNullable<Awaited<ReturnType<typeof gradeSubmission>>>
    export type GradeSubmissionMutationBody = AssignmentGradeRequest
    export type GradeSubmissionMutationError = AxiosError<unknown>

    /**
 * @summary Í∞ïÏÇ¨Ïö© - Ï†êÏàò Î∞è ÌîºÎìúÎ∞± Ï†ÄÏû•
 */
export const useGradeSubmission = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof gradeSubmission>>, TError,{academyId: number;assignmentId: number;submissionId: number;data: AssignmentGradeRequest}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof gradeSubmission>>,
        TError,
        {academyId: number;assignmentId: number;submissionId: number;data: AssignmentGradeRequest},
        TContext
      > => {

      const mutationOptions = getGradeSubmissionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary ÏãúÌóò ÏÉùÏÑ±
 */
export const createExam = (
    lectureId: number,
    examCreationRequest: ExamCreationRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ExamCreationResponse>> => {
    
    
    return axios.default.post(
      `/api/lectures/${lectureId}/exams`,
      examCreationRequest,options
    );
  }



export const getCreateExamMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createExam>>, TError,{lectureId: number;data: ExamCreationRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createExam>>, TError,{lectureId: number;data: ExamCreationRequest}, TContext> => {

const mutationKey = ['createExam'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createExam>>, {lectureId: number;data: ExamCreationRequest}> = (props) => {
          const {lectureId,data} = props ?? {};

          return  createExam(lectureId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateExamMutationResult = NonNullable<Awaited<ReturnType<typeof createExam>>>
    export type CreateExamMutationBody = ExamCreationRequest
    export type CreateExamMutationError = AxiosError<unknown>

    /**
 * @summary ÏãúÌóò ÏÉùÏÑ±
 */
export const useCreateExam = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createExam>>, TError,{lectureId: number;data: ExamCreationRequest}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof createExam>>,
        TError,
        {lectureId: number;data: ExamCreationRequest},
        TContext
      > => {

      const mutationOptions = getCreateExamMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary ÏãúÌóò Î¨∏Ï†ú Îì±Î°ù
 */
export const registerExamQuestions = (
    lectureId: number,
    examId: number,
    questionRegistrationRequest: QuestionRegistrationRequest[], options?: AxiosRequestConfig
 ): Promise<AxiosResponse<QuestionIdResponse[]>> => {
    
    
    return axios.default.post(
      `/api/lectures/${lectureId}/exams/${examId}/mcq`,
      questionRegistrationRequest,options
    );
  }



export const getRegisterExamQuestionsMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registerExamQuestions>>, TError,{lectureId: number;examId: number;data: QuestionRegistrationRequest[]}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof registerExamQuestions>>, TError,{lectureId: number;examId: number;data: QuestionRegistrationRequest[]}, TContext> => {

const mutationKey = ['registerExamQuestions'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof registerExamQuestions>>, {lectureId: number;examId: number;data: QuestionRegistrationRequest[]}> = (props) => {
          const {lectureId,examId,data} = props ?? {};

          return  registerExamQuestions(lectureId,examId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RegisterExamQuestionsMutationResult = NonNullable<Awaited<ReturnType<typeof registerExamQuestions>>>
    export type RegisterExamQuestionsMutationBody = QuestionRegistrationRequest[]
    export type RegisterExamQuestionsMutationError = AxiosError<unknown>

    /**
 * @summary ÏãúÌóò Î¨∏Ï†ú Îì±Î°ù
 */
export const useRegisterExamQuestions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registerExamQuestions>>, TError,{lectureId: number;examId: number;data: QuestionRegistrationRequest[]}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof registerExamQuestions>>,
        TError,
        {lectureId: number;examId: number;data: QuestionRegistrationRequest[]},
        TContext
      > => {

      const mutationOptions = getRegisterExamQuestionsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary ÏãúÌóò ÏÉÅÏÑ∏ Ï°∞Ìöå
 */
export const getExamDetail = (
    lectureId: number,
    examId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ExamDetailResponse>> => {
    
    
    return axios.default.get(
      `/api/lectures/${lectureId}/exams/${examId}`,options
    );
  }




export const getGetExamDetailQueryKey = (lectureId?: number,
    examId?: number,) => {
    return [
    `/api/lectures/${lectureId}/exams/${examId}`
    ] as const;
    }

    
export const getGetExamDetailQueryOptions = <TData = Awaited<ReturnType<typeof getExamDetail>>, TError = AxiosError<unknown>>(lectureId: number,
    examId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getExamDetail>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetExamDetailQueryKey(lectureId,examId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getExamDetail>>> = ({ signal }) => getExamDetail(lectureId,examId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(lectureId && examId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getExamDetail>>, TError, TData> & { queryKey: QueryKey }
}

export type GetExamDetailQueryResult = NonNullable<Awaited<ReturnType<typeof getExamDetail>>>
export type GetExamDetailQueryError = AxiosError<unknown>


/**
 * @summary ÏãúÌóò ÏÉÅÏÑ∏ Ï°∞Ìöå
 */

export function useGetExamDetail<TData = Awaited<ReturnType<typeof getExamDetail>>, TError = AxiosError<unknown>>(
 lectureId: number,
    examId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getExamDetail>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetExamDetailQueryOptions(lectureId,examId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary ÏãúÌóò ÏùëÏãú ÏãúÏûë
 */
export const startExam = (
    examId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ExamStartResponse>> => {
    
    
    return axios.default.post(
      `/api/student/exams/${examId}/start`,undefined,options
    );
  }



export const getStartExamMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof startExam>>, TError,{examId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof startExam>>, TError,{examId: number}, TContext> => {

const mutationKey = ['startExam'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof startExam>>, {examId: number}> = (props) => {
          const {examId} = props ?? {};

          return  startExam(examId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type StartExamMutationResult = NonNullable<Awaited<ReturnType<typeof startExam>>>
    
    export type StartExamMutationError = AxiosError<unknown>

    /**
 * @summary ÏãúÌóò ÏùëÏãú ÏãúÏûë
 */
export const useStartExam = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof startExam>>, TError,{examId: number}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof startExam>>,
        TError,
        {examId: number},
        TContext
      > => {

      const mutationOptions = getStartExamMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary ÎãµÏïà Ï†ÄÏû• (ÏûêÎèô/ÏàòÎèô Ï†ÄÏû•)
 */
export const saveAnswers = (
    examId: number,
    answerSaveRequest: AnswerSaveRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AnswerSaveResponse>> => {
    
    
    return axios.default.post(
      `/api/student/exams/${examId}/answers`,
      answerSaveRequest,options
    );
  }



export const getSaveAnswersMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof saveAnswers>>, TError,{examId: number;data: AnswerSaveRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof saveAnswers>>, TError,{examId: number;data: AnswerSaveRequest}, TContext> => {

const mutationKey = ['saveAnswers'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof saveAnswers>>, {examId: number;data: AnswerSaveRequest}> = (props) => {
          const {examId,data} = props ?? {};

          return  saveAnswers(examId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SaveAnswersMutationResult = NonNullable<Awaited<ReturnType<typeof saveAnswers>>>
    export type SaveAnswersMutationBody = AnswerSaveRequest
    export type SaveAnswersMutationError = AxiosError<unknown>

    /**
 * @summary ÎãµÏïà Ï†ÄÏû• (ÏûêÎèô/ÏàòÎèô Ï†ÄÏû•)
 */
export const useSaveAnswers = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof saveAnswers>>, TError,{examId: number;data: AnswerSaveRequest}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof saveAnswers>>,
        TError,
        {examId: number;data: AnswerSaveRequest},
        TContext
      > => {

      const mutationOptions = getSaveAnswersMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary ÏãúÌóò Ï†úÏ∂ú
 */
export const submitExam = (
    examId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ExamSubmitResponse>> => {
    
    
    return axios.default.post(
      `/api/student/exams/${examId}/submit`,undefined,options
    );
  }



export const getSubmitExamMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof submitExam>>, TError,{examId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof submitExam>>, TError,{examId: number}, TContext> => {

const mutationKey = ['submitExam'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof submitExam>>, {examId: number}> = (props) => {
          const {examId} = props ?? {};

          return  submitExam(examId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SubmitExamMutationResult = NonNullable<Awaited<ReturnType<typeof submitExam>>>
    
    export type SubmitExamMutationError = AxiosError<unknown>

    /**
 * @summary ÏãúÌóò Ï†úÏ∂ú
 */
export const useSubmitExam = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof submitExam>>, TError,{examId: number}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof submitExam>>,
        TError,
        {examId: number},
        TContext
      > => {

      const mutationOptions = getSubmitExamMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary ÏãúÌóò Í≤∞Í≥º Ï°∞Ìöå
 */
export const getExamResult = (
    examId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ExamResultResponse>> => {
    
    
    return axios.default.get(
      `/api/student/exams/${examId}/result`,options
    );
  }




export const getGetExamResultQueryKey = (examId?: number,) => {
    return [
    `/api/student/exams/${examId}/result`
    ] as const;
    }

    
export const getGetExamResultQueryOptions = <TData = Awaited<ReturnType<typeof getExamResult>>, TError = AxiosError<unknown>>(examId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getExamResult>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetExamResultQueryKey(examId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getExamResult>>> = ({ signal }) => getExamResult(examId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(examId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getExamResult>>, TError, TData> & { queryKey: QueryKey }
}

export type GetExamResultQueryResult = NonNullable<Awaited<ReturnType<typeof getExamResult>>>
export type GetExamResultQueryError = AxiosError<unknown>


/**
 * @summary ÏãúÌóò Í≤∞Í≥º Ï°∞Ìöå
 */

export function useGetExamResult<TData = Awaited<ReturnType<typeof getExamResult>>, TError = AxiosError<unknown>>(
 examId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getExamResult>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetExamResultQueryOptions(examId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary ÎÇ¥ ÏãúÌóò Í∏∞Î°ù Î™©Î°ù Ï°∞Ìöå
 */
export const getExamRecords = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ExamRecordResponse[]>> => {
    
    
    return axios.default.get(
      `/api/student/exams/records`,options
    );
  }




export const getGetExamRecordsQueryKey = () => {
    return [
    `/api/student/exams/records`
    ] as const;
    }

    
export const getGetExamRecordsQueryOptions = <TData = Awaited<ReturnType<typeof getExamRecords>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getExamRecords>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetExamRecordsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getExamRecords>>> = ({ signal }) => getExamRecords({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getExamRecords>>, TError, TData> & { queryKey: QueryKey }
}

export type GetExamRecordsQueryResult = NonNullable<Awaited<ReturnType<typeof getExamRecords>>>
export type GetExamRecordsQueryError = AxiosError<unknown>


/**
 * @summary ÎÇ¥ ÏãúÌóò Í∏∞Î°ù Î™©Î°ù Ï°∞Ìöå
 */

export function useGetExamRecords<TData = Awaited<ReturnType<typeof getExamRecords>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getExamRecords>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetExamRecordsQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary ÎÇ¥ Í∞ïÏùò Î™©Î°ù Ï°∞Ìöå
 */
export const getMyLectures = (
    studentId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MyLectureResponse[]>> => {
    
    
    return axios.default.get(
      `/api/students/${studentId}/lectures`,options
    );
  }




export const getGetMyLecturesQueryKey = (studentId?: number,) => {
    return [
    `/api/students/${studentId}/lectures`
    ] as const;
    }

    
export const getGetMyLecturesQueryOptions = <TData = Awaited<ReturnType<typeof getMyLectures>>, TError = AxiosError<unknown>>(studentId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMyLectures>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMyLecturesQueryKey(studentId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyLectures>>> = ({ signal }) => getMyLectures(studentId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(studentId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMyLectures>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMyLecturesQueryResult = NonNullable<Awaited<ReturnType<typeof getMyLectures>>>
export type GetMyLecturesQueryError = AxiosError<unknown>


/**
 * @summary ÎÇ¥ Í∞ïÏùò Î™©Î°ù Ï°∞Ìöå
 */

export function useGetMyLectures<TData = Awaited<ReturnType<typeof getMyLectures>>, TError = AxiosError<unknown>>(
 studentId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMyLectures>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetMyLecturesQueryOptions(studentId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Ï∂úÏÑù Ï≤¥ÌÅ¨
 */
export const checkIn = (
    studentId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AttendanceCheckInResponse>> => {
    
    
    return axios.default.post(
      `/api/students/${studentId}/attendance/check-in`,undefined,options
    );
  }



export const getCheckInMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkIn>>, TError,{studentId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof checkIn>>, TError,{studentId: number}, TContext> => {

const mutationKey = ['checkIn'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkIn>>, {studentId: number}> = (props) => {
          const {studentId} = props ?? {};

          return  checkIn(studentId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckInMutationResult = NonNullable<Awaited<ReturnType<typeof checkIn>>>
    
    export type CheckInMutationError = AxiosError<unknown>

    /**
 * @summary Ï∂úÏÑù Ï≤¥ÌÅ¨
 */
export const useCheckIn = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkIn>>, TError,{studentId: number}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof checkIn>>,
        TError,
        {studentId: number},
        TContext
      > => {

      const mutationOptions = getCheckInMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary ÎÇ¥ Í≥ºÏ†ú Î™©Î°ù
 */
export const getMyAssignments = (
    studentId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AssignmentSummaryResponse[]>> => {
    
    
    return axios.default.get(
      `/api/students/${studentId}/assignments`,options
    );
  }




export const getGetMyAssignmentsQueryKey = (studentId?: number,) => {
    return [
    `/api/students/${studentId}/assignments`
    ] as const;
    }

    
export const getGetMyAssignmentsQueryOptions = <TData = Awaited<ReturnType<typeof getMyAssignments>>, TError = AxiosError<unknown>>(studentId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMyAssignments>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMyAssignmentsQueryKey(studentId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyAssignments>>> = ({ signal }) => getMyAssignments(studentId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(studentId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMyAssignments>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMyAssignmentsQueryResult = NonNullable<Awaited<ReturnType<typeof getMyAssignments>>>
export type GetMyAssignmentsQueryError = AxiosError<unknown>


/**
 * @summary ÎÇ¥ Í≥ºÏ†ú Î™©Î°ù
 */

export function useGetMyAssignments<TData = Awaited<ReturnType<typeof getMyAssignments>>, TError = AxiosError<unknown>>(
 studentId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMyAssignments>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetMyAssignmentsQueryOptions(studentId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary ÎÇ¥ ÏãúÌóò Î™©Î°ù
 */
export const getMyExams = (
    studentId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ExamSummaryResponse[]>> => {
    
    
    return axios.default.get(
      `/api/students/${studentId}/exams`,options
    );
  }




export const getGetMyExamsQueryKey = (studentId?: number,) => {
    return [
    `/api/students/${studentId}/exams`
    ] as const;
    }

    
export const getGetMyExamsQueryOptions = <TData = Awaited<ReturnType<typeof getMyExams>>, TError = AxiosError<unknown>>(studentId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMyExams>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMyExamsQueryKey(studentId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyExams>>> = ({ signal }) => getMyExams(studentId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(studentId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMyExams>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMyExamsQueryResult = NonNullable<Awaited<ReturnType<typeof getMyExams>>>
export type GetMyExamsQueryError = AxiosError<unknown>


/**
 * @summary ÎÇ¥ ÏãúÌóò Î™©Î°ù
 */

export function useGetMyExams<TData = Awaited<ReturnType<typeof getMyExams>>, TError = AxiosError<unknown>>(
 studentId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMyExams>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetMyExamsQueryOptions(studentId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary ÌïôÏÉù ÌÜµÌï© Î∂ÑÏÑù Î¶¨Ìè¨Ìä∏ Ï°∞Ìöå
 */
export const getStudentAnalysis = (
    studentId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<StudentAnalysisResponse>> => {
    
    
    return axios.default.get(
      `/api/analysis/student/${studentId}`,options
    );
  }




export const getGetStudentAnalysisQueryKey = (studentId?: number,) => {
    return [
    `/api/analysis/student/${studentId}`
    ] as const;
    }

    
export const getGetStudentAnalysisQueryOptions = <TData = Awaited<ReturnType<typeof getStudentAnalysis>>, TError = AxiosError<void>>(studentId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getStudentAnalysis>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStudentAnalysisQueryKey(studentId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStudentAnalysis>>> = ({ signal }) => getStudentAnalysis(studentId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(studentId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getStudentAnalysis>>, TError, TData> & { queryKey: QueryKey }
}

export type GetStudentAnalysisQueryResult = NonNullable<Awaited<ReturnType<typeof getStudentAnalysis>>>
export type GetStudentAnalysisQueryError = AxiosError<void>


/**
 * @summary ÌïôÏÉù ÌÜµÌï© Î∂ÑÏÑù Î¶¨Ìè¨Ìä∏ Ï°∞Ìöå
 */

export function useGetStudentAnalysis<TData = Awaited<ReturnType<typeof getStudentAnalysis>>, TError = AxiosError<void>>(
 studentId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getStudentAnalysis>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetStudentAnalysisQueryOptions(studentId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary ÌïôÏÉù Ï†ÑÏ≤¥ ÏãúÌóò ÏöîÏïΩ Ï°∞Ìöå
 */
export const getExamSummary = (
    studentId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<StudentExamSummaryResponse[]>> => {
    
    
    return axios.default.get(
      `/api/students/${studentId}/analysis/exams`,options
    );
  }




export const getGetExamSummaryQueryKey = (studentId?: number,) => {
    return [
    `/api/students/${studentId}/analysis/exams`
    ] as const;
    }

    
export const getGetExamSummaryQueryOptions = <TData = Awaited<ReturnType<typeof getExamSummary>>, TError = AxiosError<void>>(studentId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getExamSummary>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetExamSummaryQueryKey(studentId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getExamSummary>>> = ({ signal }) => getExamSummary(studentId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(studentId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getExamSummary>>, TError, TData> & { queryKey: QueryKey }
}

export type GetExamSummaryQueryResult = NonNullable<Awaited<ReturnType<typeof getExamSummary>>>
export type GetExamSummaryQueryError = AxiosError<void>


/**
 * @summary ÌïôÏÉù Ï†ÑÏ≤¥ ÏãúÌóò ÏöîÏïΩ Ï°∞Ìöå
 */

export function useGetExamSummary<TData = Awaited<ReturnType<typeof getExamSummary>>, TError = AxiosError<void>>(
 studentId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getExamSummary>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetExamSummaryQueryOptions(studentId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary ÌïôÏÉùÏùò Îã®ÏõêÎ≥Ñ ÏÑ±Ï∑®ÎèÑ Ï°∞Ìöå (Ï†ïÎãµÎ•† ÎÇÆÏùÄ Ïàú)
 */
export const getWeakUnits = (
    studentId: number,
    params?: GetWeakUnitsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<StudentUnitCorrectRateResponse[]>> => {
    
    
    return axios.default.get(
      `/api/students/${studentId}/analysis/weak-units`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getGetWeakUnitsQueryKey = (studentId?: number,
    params?: GetWeakUnitsParams,) => {
    return [
    `/api/students/${studentId}/analysis/weak-units`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetWeakUnitsQueryOptions = <TData = Awaited<ReturnType<typeof getWeakUnits>>, TError = AxiosError<void>>(studentId: number,
    params?: GetWeakUnitsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getWeakUnits>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWeakUnitsQueryKey(studentId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWeakUnits>>> = ({ signal }) => getWeakUnits(studentId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(studentId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWeakUnits>>, TError, TData> & { queryKey: QueryKey }
}

export type GetWeakUnitsQueryResult = NonNullable<Awaited<ReturnType<typeof getWeakUnits>>>
export type GetWeakUnitsQueryError = AxiosError<void>


/**
 * @summary ÌïôÏÉùÏùò Îã®ÏõêÎ≥Ñ ÏÑ±Ï∑®ÎèÑ Ï°∞Ìöå (Ï†ïÎãµÎ•† ÎÇÆÏùÄ Ïàú)
 */

export function useGetWeakUnits<TData = Awaited<ReturnType<typeof getWeakUnits>>, TError = AxiosError<void>>(
 studentId: number,
    params?: GetWeakUnitsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getWeakUnits>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetWeakUnitsQueryOptions(studentId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary ÌïôÏÉùÏùò Í∞ïÏùòÎ≥Ñ ÏõîÍ∞Ñ Ï∂úÏÑù ÌòÑÌô© Ï°∞Ìöå
 */
export const getMonthlyAttendance = (
    studentId: number,
    lectureId: number,
    params: GetMonthlyAttendanceParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<StudentLectureAttendanceResponse>> => {
    
    
    return axios.default.get(
      `/api/students/${studentId}/lectures/${lectureId}/attendance/monthly`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getGetMonthlyAttendanceQueryKey = (studentId?: number,
    lectureId?: number,
    params?: GetMonthlyAttendanceParams,) => {
    return [
    `/api/students/${studentId}/lectures/${lectureId}/attendance/monthly`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetMonthlyAttendanceQueryOptions = <TData = Awaited<ReturnType<typeof getMonthlyAttendance>>, TError = AxiosError<void>>(studentId: number,
    lectureId: number,
    params: GetMonthlyAttendanceParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMonthlyAttendance>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMonthlyAttendanceQueryKey(studentId,lectureId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMonthlyAttendance>>> = ({ signal }) => getMonthlyAttendance(studentId,lectureId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(studentId && lectureId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMonthlyAttendance>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMonthlyAttendanceQueryResult = NonNullable<Awaited<ReturnType<typeof getMonthlyAttendance>>>
export type GetMonthlyAttendanceQueryError = AxiosError<void>


/**
 * @summary ÌïôÏÉùÏùò Í∞ïÏùòÎ≥Ñ ÏõîÍ∞Ñ Ï∂úÏÑù ÌòÑÌô© Ï°∞Ìöå
 */

export function useGetMonthlyAttendance<TData = Awaited<ReturnType<typeof getMonthlyAttendance>>, TError = AxiosError<void>>(
 studentId: number,
    lectureId: number,
    params: GetMonthlyAttendanceParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMonthlyAttendance>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetMonthlyAttendanceQueryOptions(studentId,lectureId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}
