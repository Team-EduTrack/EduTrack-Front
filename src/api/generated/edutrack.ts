/**
 * Generated by orval v7.17.0 ğŸº
 * Do not edit manually.
 * EduTrack API
 * EduTrack ë°±ì—”ë“œ(Spring Boot 3, Java 17)ìš© OpenAPI ìŠ¤í™
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import * as axios from 'axios';
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios';

export interface SignInRequest {
  loginId: string;
  password: string;
}

export interface SignInResponse {
  accessToken?: string;
  refreshToken?: string;
  user?: UserInfo;
}

export interface UserInfo {
  id?: number;
  name?: string;
  role?: string;
}

export interface MyInfoResponse {
  id?: number;
  name?: string;
  email?: string;
  phone?: string;
  role?: string;
}

export interface SignupRequest {
  loginId: string;
  password: string;
  name: string;
  phone: string;
  email: string;
  academyCode: string;
}

export interface SignupInitResponse {
  signupToken: string;
}

export interface SignupResponse {
  id?: number;
  loginId?: string;
  name?: string;
  role?: string;
}

export interface SendEmailVerificationRequest {
  signupToken: string;
}

export interface VerifyEmailRequest {
  signupToken: string;
  inputCode: string;
}

export interface AcademyVerifyRequest {
  signupToken: string;
  academyCode: string;
}

export interface CompleteSignupRequest {
  signupToken: string;
}

export interface UserSearchResultResponse {
  id?: number;
  name?: string;
  loginId?: string;
  phone?: string;
  email?: string;
  role?: string;
}

export interface SearchAllUserResponse {
  /** ì‚¬ìš©ì ëª©ë¡ */
  users?: UserSearchResultResponse[];
  /** ì „ì²´ ì‚¬ìš©ì ìˆ˜ */
  totalCount?: number;
}

export interface PrincipalRegistrationRequest {
  principalName: string;
  loginId: string;
  password: string;
  passwordConfirm: string;
  phone: string;
  email: string;
  academyName: string;
}

export interface PrincipalRegistrationResponse {
  id?: number;
  academyName?: string;
  academyCode?: string;
}

export type LectureCreationRequestDaysOfWeekItem = typeof LectureCreationRequestDaysOfWeekItem[keyof typeof LectureCreationRequestDaysOfWeekItem];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LectureCreationRequestDaysOfWeekItem = {
  MONDAY: 'MONDAY',
  TUESDAY: 'TUESDAY',
  WEDNESDAY: 'WEDNESDAY',
  THURSDAY: 'THURSDAY',
  FRIDAY: 'FRIDAY',
  SATURDAY: 'SATURDAY',
  SUNDAY: 'SUNDAY',
} as const;

export interface LectureCreationRequest {
  /** ê°•ì˜ ì œëª© (í•„ìˆ˜) */
  title: string;
  /**
   * ê°•ì˜ ì„¤ëª… (ì„ íƒ)
   * @nullable
   */
  description?: string | null;
  /** ê°•ì‚¬ ID (í•„ìˆ˜) */
  teacherId: number;
  /**
   * ê°•ì˜ ìš”ì¼ ëª©ë¡ (í•„ìˆ˜, ìµœì†Œ 1ê°œ ì´ìƒ)
   * @minItems 1
   */
  daysOfWeek: LectureCreationRequestDaysOfWeekItem[];
  /** ê°•ì˜ ì‹œì‘ì¼ (í•„ìˆ˜) */
  startDate: string;
  /** ê°•ì˜ ì¢…ë£Œì¼ (í•„ìˆ˜, ë¯¸ë˜ ë‚ ì§œ) */
  endDate: string;
}

export interface LectureCreationResponse {
  lectureId?: number;
}

export interface LectureForTeacherResponse {
  lectureId?: number;
  title?: string;
  studentCount?: number;
  /**
   * ê°•ì‚¬ëª… (ì›ì¥ ì¡°íšŒ ì‹œ í¬í•¨, ì„ ìƒë‹˜ ë³¸ì¸ ì¡°íšŒ ì‹œ null)
   * @nullable
   */
  teacherName?: string | null;
  /**
   * í‰ê·  ì ìˆ˜
   * @nullable
   */
  averageGrade?: number | null;
}

export type LectureDetailForTeacherResponseAllOf = {
  description?: string;
  studentDetails?: StudentInfo[];
  assignmentsWithSubmissions?: AssignmentWithSubmissions[];
  examsWithParticipation?: ExamParticipationInfo[];
};

export type LectureDetailForTeacherResponse = LectureForTeacherResponse & LectureDetailForTeacherResponseAllOf;

export interface StudentInfo {
  id?: number;
  name?: string;
}

export interface AssignmentWithSubmissions {
  assignmentId?: number;
  assignmentTitle?: string;
  submittedStudents?: SubmissionStudentInfo[];
}

export interface SubmissionStudentInfo {
  studentId?: number;
  studentName?: string;
  submissionId?: number;
}

export interface ExamParticipationInfo {
  examId?: number;
  examTitle?: string;
  participatedCount?: number;
  totalStudentCount?: number;
}

export interface LectureDetailWithStatisticsResponse {
  lectureDetailForTeacherResponse?: LectureDetailForTeacherResponse;
  lectureStatisticsResponse?: LectureStatisticsResponse;
}

export interface LectureStatisticsResponse {
  lectureId?: number;
  studentCount?: number;
  attendanceRate?: number;
  assignmentSubmissionRate?: number;
  examParticipationRate?: number;
  averageScore?: number;
  total10PercentScore?: number;
}

export interface UnitCorrectRateResponse {
  unitId?: number;
  /** ì „ì²´ ì‹œë„ íšŸìˆ˜ */
  totalTryCount?: number;
  /** ì •ë‹µ íšŸìˆ˜ */
  correctCount?: number;
  /** ì •ë‹µë¥  */
  correctRate?: number;
}

export interface StudentSearchResponse {
  studentId?: number;
  name?: string;
}

export interface LectureStudentAssignRequest {
  studentIds: number[];
}

export interface LectureStudentAssignResponse {
  lectureId?: number;
  assignedCount?: number;
}

export interface AssignmentCreateRequest {
  lectureId: number;
  title: string;
  description?: string;
  dueDate: string;
}

export interface AssignmentCreateResponse {
  assignmentId?: number;
}

export interface PresignedUrlRequest {
  fileName: string;
  contentType?: string;
}

export interface PresignedUrlResponse {
  url?: string;
  fileKey?: string;
}

export interface AssignmentSubmitRequest {
  fileKey?: string;
  comment?: string;
}

export interface AssignmentSubmitResponse {
  submissionId?: number;
  submittedAt?: string;
}

export type AssignmentListResponseStatus = typeof AssignmentListResponseStatus[keyof typeof AssignmentListResponseStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AssignmentListResponseStatus = {
  NOT_SUBMITTED: 'NOT_SUBMITTED',
  SUBMITTED: 'SUBMITTED',
} as const;

export interface AssignmentListResponse {
  assignmentId?: number;
  title?: string;
  endDate?: string;
  status?: AssignmentListResponseStatus;
}

export interface AssignmentSubmissionListResponse {
  submissionId?: number;
  studentId?: number;
  studentName?: string;
  fileUrl?: string;
  submittedAt?: string;
}

export interface AssignmentSubmissionStudentViewResponse {
  submitted?: boolean;
  /** @nullable */
  submissionId?: number | null;
  assignmentId?: number;
  lectureName?: string;
  teacherName?: string;
  assignmentTitle?: string;
  assignmentDescription?: string;
  endDate?: string;
  /** @nullable */
  filePath?: string | null;
  /** @nullable */
  score?: number | null;
  /** @nullable */
  feedback?: string | null;
}

export interface AssignmentSubmissionTeacherViewResponse {
  submissionId?: number;
  assignmentId?: number;
  lectureName?: string;
  teacherName?: string;
  studentLoginId?: string;
  studentName?: string;
  assignmentTitle?: string;
  assignmentDescription?: string;
  filePath?: string;
  /** @nullable */
  score?: number | null;
  /** @nullable */
  feedback?: string | null;
}

export interface AssignmentGradeRequest {
  /**
   * @minimum 0
   * @maximum 100
   */
  score: number;
  feedback?: string;
}

export interface AssignmentGradeResponse {
  submissionId?: number;
  assignmentId?: number;
  studentId?: number;
  score?: number;
  feedback?: string;
}

export interface ExamCreationRequest {
  lectureId: number;
  title: string;
  description?: string;
  startDate: string;
  endDate: string;
  /** @minimum 5 */
  durationMinute: number;
}

export interface ExamCreationResponse {
  examId?: number;
}

export type QuestionRegistrationRequestDifficulty = typeof QuestionRegistrationRequestDifficulty[keyof typeof QuestionRegistrationRequestDifficulty];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const QuestionRegistrationRequestDifficulty = {
  EASY: 'EASY',
  MEDIUM: 'MEDIUM',
  HARD: 'HARD',
} as const;

export interface QuestionRegistrationRequest {
  questionText: string;
  choices: string[];
  correctAnswerIndex: number;
  difficulty: QuestionRegistrationRequestDifficulty;
  unitId: number;
}

export interface QuestionIdResponse {
  questionId?: number;
}

export interface ExamDetailResponse {
  examId?: number;
  lectureId?: number;
  title?: string;
  startDate?: string;
  endDate?: string;
  durationMinute?: number;
  status?: string;
  questions?: QuestionDetail[];
}

export interface QuestionDetail {
  questionId?: number;
  content?: string;
  score?: number;
  answerNumber?: number;
  difficulty?: string;
  unitId?: number;
  choices?: ChoiceDetail[];
}

export interface ChoiceDetail {
  choiceId?: number;
  content?: string;
  choiceNumber?: number;
}

export interface ExamStartResponse {
  examId?: number;
  studentId?: number;
  title?: string;
  startDate?: string;
  endDate?: string;
  durationMinute?: number;
  startedAt?: string;
  examStartedAt?: string;
  personalDeadline?: string;
  status?: string;
  questions?: QuestionForStudent[];
}

export interface QuestionForStudent {
  questionId?: number;
  content?: string;
  score?: number;
  difficulty?: string;
  choices?: ChoiceForStudent[];
}

export interface ChoiceForStudent {
  choiceId?: number;
  content?: string;
  choiceNumber?: number;
}

export interface AnswerSaveRequest {
  answers: AnswerSubmitRequest[];
}

export interface AnswerSubmitRequest {
  questionId: number;
  selectedAnswerNumber: number;
}

export interface AnswerSaveResponse {
  examId?: number;
  studentId?: number;
  savedCount?: number;
  savedAt?: string;
}

export interface ExamSubmitResponse {
  examId?: number;
  studentId?: number;
  submittedAt?: string;
  message?: string;
}

export interface ExamResultResponse {
  examId?: number;
  examTitle?: string;
  studentId?: number;
  studentName?: string;
  status?: string;
  totalScore?: number;
  earnedScore?: number;
  correctCount?: number;
  totalQuestionCount?: number;
  startedAt?: string;
  submittedAt?: string;
  questionResults?: QuestionResult[];
}

export interface QuestionResult {
  questionId?: number;
  content?: string;
  score?: number;
  submittedAnswer?: number;
  correctAnswer?: number;
  isCorrect?: boolean;
  unitId?: number;
  difficulty?: string;
  earnedScore?: number;
}

export interface ExamRecordResponse {
  examId?: number;
  examTitle?: string;
  lectureName?: string;
  status?: string;
  totalScore?: number;
  earnedScore?: number;
  startedAt?: string;
  submittedAt?: string;
  examStartDate?: string;
  examEndDate?: string;
}

export interface QuestionCorrectRateResponse {
  questionId?: number;
  questionContent?: string;
  totalCount?: number;
  correctCount?: number;
  correctRate?: number;
}

export interface StudentQuestionStatisticsResponse {
  questionId?: number;
  questionContent?: string;
  correctAnswer?: number;
  /** @nullable */
  submittedAnswer?: number | null;
  isCorrect?: boolean;
  earnedScore?: number;
  maxScore?: number;
  totalCount?: number;
  correctCount?: number;
  correctRate?: number;
}

export interface MyLectureResponse {
  lectureId?: number;
  lectureTitle?: string;
  teacherName?: string;
  description?: string;
  startDate?: string;
  endDate?: string;
}

export interface MyLectureDetailResponse {
  lectureId?: number;
  lectureTitle?: string;
  teacherName?: string;
  description?: string;
  /** ì¶œì„ë¥  (ë°±ë¶„ìœ¨, ì†Œìˆ˜ì  ì²«ì§¸ ìë¦¬ê¹Œì§€) */
  attendanceRate?: number;
  /** ê³¼ì œ ì œì¶œë¥  (ë°±ë¶„ìœ¨, ì†Œìˆ˜ì  ì²«ì§¸ ìë¦¬ê¹Œì§€) */
  assignmentSubmissionRate?: number;
  /** ë¯¸ì‘ì‹œ ì‹œí—˜ ëª©ë¡ (ì´ë¯¸ ì‹œì‘í•œ ì‹œí—˜ì€ ì œì™¸) */
  exams?: ExamInfo[];
  /** ë¯¸ì œì¶œ ê³¼ì œ ëª©ë¡ (ì´ë¯¸ ì œì¶œí•œ ê³¼ì œëŠ” ì œì™¸) */
  assignments?: AssignmentInfo[];
}

/**
 * ì‹œí—˜ ìƒíƒœ
 */
export type ExamInfoStatus = typeof ExamInfoStatus[keyof typeof ExamInfoStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ExamInfoStatus = {
  DRAFT: 'DRAFT',
  PUBLISHED: 'PUBLISHED',
  CLOSED: 'CLOSED',
} as const;

export interface ExamInfo {
  examId?: number;
  examTitle?: string;
  startDate?: string;
  endDate?: string;
  /** ì‹œí—˜ ìƒíƒœ */
  status?: ExamInfoStatus;
}

/**
 * ê³¼ì œ ì œì¶œ ìƒíƒœ
 */
export type AssignmentInfoStatus = typeof AssignmentInfoStatus[keyof typeof AssignmentInfoStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AssignmentInfoStatus = {
  NOT_SUBMITTED: 'NOT_SUBMITTED',
  SUBMITTED: 'SUBMITTED',
} as const;

export interface AssignmentInfo {
  assignmentId?: number;
  assignmentTitle?: string;
  startDate?: string;
  endDate?: string;
  /** ê³¼ì œ ì œì¶œ ìƒíƒœ */
  status?: AssignmentInfoStatus;
  /**
   * íšë“ ì ìˆ˜ (ì œì¶œí•˜ì§€ ì•Šì€ ê³¼ì œëŠ” null)
   * @nullable
   */
  earnedScore?: number | null;
}

export interface AttendanceCheckInResponse {
  studentId?: number;
  attendanceDate?: string;
  alreadyCheckedIn?: boolean;
}

export interface AssignmentSummaryResponse {
  assignmentId?: number;
  lectureTitle?: string;
  title?: string;
  startDate?: string;
  endDate?: string;
  /** @nullable */
  score?: number | null;
}

export interface ExamSummaryResponse {
  examId?: number;
  lectureTitle?: string;
  title?: string;
  startDate?: string;
  endDate?: string;
  /** @nullable */
  earnedScore?: number | null;
  status?: string;
}

export interface StudentAnalysisResponse {
  studentId?: number;
  /** @nullable */
  avgScore?: number | null;
  unitWeak?: string[];
  trend?: number[];
}

export interface StudentExamSummaryResponse {
  examId?: number;
  examTitle?: string;
  lectureName?: string;
  /** @nullable */
  totalScore?: number | null;
  /** @nullable */
  earnedScore?: number | null;
  /** @nullable */
  submittedAt?: string | null;
}

export interface StudentUnitCorrectRateResponse {
  unitId?: number;
  studentId?: number;
  totalTryCount?: number;
  correctCount?: number;
  correctRate?: number;
}

export interface StudentLectureAttendanceResponse {
  lectureId?: number;
  lectureName?: string;
  year?: number;
  month?: number;
  attendedDates?: string[];
  totalClassDays?: number;
  attendedDays?: number;
  attendanceRate?: number;
  otherStudentsAvgAttendanceRate?: number;
}

export type SearchUsersParams = {
role?: SearchUsersRole;
keyword?: string;
};

export type SearchUsersRole = typeof SearchUsersRole[keyof typeof SearchUsersRole];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SearchUsersRole = {
  STUDENT: 'STUDENT',
  TEACHER: 'TEACHER',
  PRINCIPAL: 'PRINCIPAL',
  ADMIN: 'ADMIN',
} as const;

export type GetAvailableStudentsForLectureParams = {
name: string;
};

export type SubmitAssignmentParams = {
studentId: number;
};

export type SubmitAssignmentParams = {
studentId: number;
};

export type GetWeakUnitsParams = {
limit?: number;
};

export type GetMonthlyAttendanceParams = {
year: number;
/**
 * @minimum 1
 * @maximum 12
 */
month: number;
};

/**
 * @summary ì‚¬ìš©ì ë¡œê·¸ì¸
 */
export const signIn = (
    signInRequest: SignInRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SignInResponse>> => {
    
    
    return axios.default.post(
      `/api/users/signin`,
      signInRequest,options
    );
  }



export const getSignInMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof signIn>>, TError,{data: SignInRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof signIn>>, TError,{data: SignInRequest}, TContext> => {

const mutationKey = ['signIn'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof signIn>>, {data: SignInRequest}> = (props) => {
          const {data} = props ?? {};

          return  signIn(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SignInMutationResult = NonNullable<Awaited<ReturnType<typeof signIn>>>
    export type SignInMutationBody = SignInRequest
    export type SignInMutationError = AxiosError<unknown>

    /**
 * @summary ì‚¬ìš©ì ë¡œê·¸ì¸
 */
export const useSignIn = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof signIn>>, TError,{data: SignInRequest}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof signIn>>,
        TError,
        {data: SignInRequest},
        TContext
      > => {

      const mutationOptions = getSignInMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary ì‚¬ìš©ì ë¡œê·¸ì•„ì›ƒ
 */
export const logout = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.post(
      `/api/users/logout`,undefined,options
    );
  }



export const getLogoutMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError,void, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError,void, TContext> => {

const mutationKey = ['logout'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof logout>>, void> = () => {
          

          return  logout(axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LogoutMutationResult = NonNullable<Awaited<ReturnType<typeof logout>>>
    
    export type LogoutMutationError = AxiosError<unknown>

    /**
 * @summary ì‚¬ìš©ì ë¡œê·¸ì•„ì›ƒ
 */
export const useLogout = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError,void, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof logout>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getLogoutMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary ë‚´ ì •ë³´ ì¡°íšŒ
 */
export const getMyInfo = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MyInfoResponse>> => {
    
    
    return axios.default.get(
      `/api/users/me`,options
    );
  }




export const getGetMyInfoQueryKey = () => {
    return [
    `/api/users/me`
    ] as const;
    }

    
export const getGetMyInfoQueryOptions = <TData = Awaited<ReturnType<typeof getMyInfo>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMyInfo>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMyInfoQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyInfo>>> = ({ signal }) => getMyInfo({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMyInfo>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMyInfoQueryResult = NonNullable<Awaited<ReturnType<typeof getMyInfo>>>
export type GetMyInfoQueryError = AxiosError<unknown>


/**
 * @summary ë‚´ ì •ë³´ ì¡°íšŒ
 */

export function useGetMyInfo<TData = Awaited<ReturnType<typeof getMyInfo>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMyInfo>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetMyInfoQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * ê´€ë¦¬ìê°€ ì‹œìŠ¤í…œì˜ ëª¨ë“  ì‚¬ìš©ì(ëª¨ë“  í•™ì› ì†Œì†)ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary ê´€ë¦¬ì ì „ìš© ëª¨ë“  ì‚¬ìš©ì ì¡°íšŒ
 */
export const getAllUsers = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SearchAllUserResponse>> => {
    
    
    return axios.default.get(
      `/api/admin/users`,options
    );
  }




export const getGetAllUsersQueryKey = () => {
    return [
    `/api/admin/users`
    ] as const;
    }

    
export const getGetAllUsersQueryOptions = <TData = Awaited<ReturnType<typeof getAllUsers>>, TError = AxiosError<void>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAllUsers>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllUsersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllUsers>>> = ({ signal }) => getAllUsers({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllUsers>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAllUsersQueryResult = NonNullable<Awaited<ReturnType<typeof getAllUsers>>>
export type GetAllUsersQueryError = AxiosError<void>


/**
 * @summary ê´€ë¦¬ì ì „ìš© ëª¨ë“  ì‚¬ìš©ì ì¡°íšŒ
 */

export function useGetAllUsers<TData = Awaited<ReturnType<typeof getAllUsers>>, TError = AxiosError<void>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAllUsers>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAllUsersQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary íšŒì›ê°€ì…
 */
export const signupRequest = (
    signupRequest: SignupRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SignupInitResponse>> => {
    
    
    return axios.default.post(
      `/api/auth/signup/request`,
      signupRequest,options
    );
  }



export const getSignupRequestMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof signupRequest>>, TError,{data: SignupRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof signupRequest>>, TError,{data: SignupRequest}, TContext> => {

const mutationKey = ['signupRequest'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof signupRequest>>, {data: SignupRequest}> = (props) => {
          const {data} = props ?? {};

          return  signupRequest(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SignupRequestMutationResult = NonNullable<Awaited<ReturnType<typeof signupRequest>>>
    export type SignupRequestMutationBody = SignupRequest
    export type SignupRequestMutationError = AxiosError<unknown>

    /**
 * @summary íšŒì›ê°€ì…
 */
export const useSignupRequest = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof signupRequest>>, TError,{data: SignupRequest}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof signupRequest>>,
        TError,
        {data: SignupRequest},
        TContext
      > => {

      const mutationOptions = getSignupRequestMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary ì´ë©”ì¼ ì¸ì¦ ì½”ë“œ ë°œì†¡
 */
export const sendEmailVerification = (
    sendEmailVerificationRequest: SendEmailVerificationRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    
    
    return axios.default.post(
      `/api/auth/send-email-verification`,
      sendEmailVerificationRequest,{
    ...options,}
    );
  }



export const getSendEmailVerificationMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sendEmailVerification>>, TError,{data: SendEmailVerificationRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof sendEmailVerification>>, TError,{data: SendEmailVerificationRequest}, TContext> => {

const mutationKey = ['sendEmailVerification'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sendEmailVerification>>, {data: SendEmailVerificationRequest}> = (props) => {
          const {data} = props ?? {};

          return  sendEmailVerification(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SendEmailVerificationMutationResult = NonNullable<Awaited<ReturnType<typeof sendEmailVerification>>>
    export type SendEmailVerificationMutationBody = SendEmailVerificationRequest
    export type SendEmailVerificationMutationError = AxiosError<unknown>

    /**
 * @summary ì´ë©”ì¼ ì¸ì¦ ì½”ë“œ ë°œì†¡
 */
export const useSendEmailVerification = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sendEmailVerification>>, TError,{data: SendEmailVerificationRequest}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof sendEmailVerification>>,
        TError,
        {data: SendEmailVerificationRequest},
        TContext
      > => {

      const mutationOptions = getSendEmailVerificationMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary ì´ë©”ì¼ ì¸ì¦ í™•ì¸
 */
export const verifyEmail = (
    verifyEmailRequest: VerifyEmailRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    
    
    return axios.default.post(
      `/api/auth/verify-email`,
      verifyEmailRequest,{
    ...options,}
    );
  }



export const getVerifyEmailMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof verifyEmail>>, TError,{data: VerifyEmailRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof verifyEmail>>, TError,{data: VerifyEmailRequest}, TContext> => {

const mutationKey = ['verifyEmail'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof verifyEmail>>, {data: VerifyEmailRequest}> = (props) => {
          const {data} = props ?? {};

          return  verifyEmail(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type VerifyEmailMutationResult = NonNullable<Awaited<ReturnType<typeof verifyEmail>>>
    export type VerifyEmailMutationBody = VerifyEmailRequest
    export type VerifyEmailMutationError = AxiosError<unknown>

    /**
 * @summary ì´ë©”ì¼ ì¸ì¦ í™•ì¸
 */
export const useVerifyEmail = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof verifyEmail>>, TError,{data: VerifyEmailRequest}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof verifyEmail>>,
        TError,
        {data: VerifyEmailRequest},
        TContext
      > => {

      const mutationOptions = getVerifyEmailMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary í•™ì› ì½”ë“œ ì¸ì¦
 */
export const verifyAcademy = (
    academyVerifyRequest: AcademyVerifyRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    
    
    return axios.default.post(
      `/api/auth/academy-verify`,
      academyVerifyRequest,{
    ...options,}
    );
  }



export const getVerifyAcademyMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof verifyAcademy>>, TError,{data: AcademyVerifyRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof verifyAcademy>>, TError,{data: AcademyVerifyRequest}, TContext> => {

const mutationKey = ['verifyAcademy'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof verifyAcademy>>, {data: AcademyVerifyRequest}> = (props) => {
          const {data} = props ?? {};

          return  verifyAcademy(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type VerifyAcademyMutationResult = NonNullable<Awaited<ReturnType<typeof verifyAcademy>>>
    export type VerifyAcademyMutationBody = AcademyVerifyRequest
    export type VerifyAcademyMutationError = AxiosError<unknown>

    /**
 * @summary í•™ì› ì½”ë“œ ì¸ì¦
 */
export const useVerifyAcademy = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof verifyAcademy>>, TError,{data: AcademyVerifyRequest}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof verifyAcademy>>,
        TError,
        {data: AcademyVerifyRequest},
        TContext
      > => {

      const mutationOptions = getVerifyAcademyMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary ìµœì¢… íšŒì›ê°€ì… ì™„ë£Œ
 */
export const completeSignup = (
    completeSignupRequest: CompleteSignupRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SignupResponse>> => {
    
    
    return axios.default.post(
      `/api/auth/signup/complete`,
      completeSignupRequest,options
    );
  }



export const getCompleteSignupMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof completeSignup>>, TError,{data: CompleteSignupRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof completeSignup>>, TError,{data: CompleteSignupRequest}, TContext> => {

const mutationKey = ['completeSignup'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof completeSignup>>, {data: CompleteSignupRequest}> = (props) => {
          const {data} = props ?? {};

          return  completeSignup(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CompleteSignupMutationResult = NonNullable<Awaited<ReturnType<typeof completeSignup>>>
    export type CompleteSignupMutationBody = CompleteSignupRequest
    export type CompleteSignupMutationError = AxiosError<unknown>

    /**
 * @summary ìµœì¢… íšŒì›ê°€ì… ì™„ë£Œ
 */
export const useCompleteSignup = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof completeSignup>>, TError,{data: CompleteSignupRequest}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof completeSignup>>,
        TError,
        {data: CompleteSignupRequest},
        TContext
      > => {

      const mutationOptions = getCompleteSignupMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary í•™ìƒ ê°œì¸ + íŠ¹ì • ì‹œí—˜ ë¬¸í•­ë³„ ì •ë‹µë¥  ì¡°íšŒ
 */
export const getStudentQuestionStatistics = (
    examId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<StudentQuestionStatisticsResponse[]>> => {
    
    
    return axios.default.get(
      `/api/student/statistics/exams/${examId}/questions`,options
    );
  }




export const getGetStudentQuestionStatisticsQueryKey = (examId?: number,) => {
    return [
    `/api/student/statistics/exams/${examId}/questions`
    ] as const;
    }

    
export const getGetStudentQuestionStatisticsQueryOptions = <TData = Awaited<ReturnType<typeof getStudentQuestionStatistics>>, TError = AxiosError<unknown>>(examId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getStudentQuestionStatistics>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStudentQuestionStatisticsQueryKey(examId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStudentQuestionStatistics>>> = ({ signal }) => getStudentQuestionStatistics(examId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(examId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getStudentQuestionStatistics>>, TError, TData> & { queryKey: QueryKey }
}

export type GetStudentQuestionStatisticsQueryResult = NonNullable<Awaited<ReturnType<typeof getStudentQuestionStatistics>>>
export type GetStudentQuestionStatisticsQueryError = AxiosError<unknown>


/**
 * @summary í•™ìƒ ê°œì¸ + íŠ¹ì • ì‹œí—˜ ë¬¸í•­ë³„ ì •ë‹µë¥  ì¡°íšŒ
 */

export function useGetStudentQuestionStatistics<TData = Awaited<ReturnType<typeof getStudentQuestionStatistics>>, TError = AxiosError<unknown>>(
 examId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getStudentQuestionStatistics>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetStudentQuestionStatisticsQueryOptions(examId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary ê°•ì‚¬ìš©: íŠ¹ì • ì‹œí—˜ ë¬¸í•­ë³„ ì •ë‹µë¥ 
 */
export const getExamQuestionCorrectRates = (
    examId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<QuestionCorrectRateResponse[]>> => {
    
    
    return axios.default.get(
      `/api/statistics/exams/${examId}/questions`,options
    );
  }




export const getGetExamQuestionCorrectRatesQueryKey = (examId?: number,) => {
    return [
    `/api/statistics/exams/${examId}/questions`
    ] as const;
    }

    
export const getGetExamQuestionCorrectRatesQueryOptions = <TData = Awaited<ReturnType<typeof getExamQuestionCorrectRates>>, TError = AxiosError<unknown>>(examId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getExamQuestionCorrectRates>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetExamQuestionCorrectRatesQueryKey(examId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getExamQuestionCorrectRates>>> = ({ signal }) => getExamQuestionCorrectRates(examId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(examId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getExamQuestionCorrectRates>>, TError, TData> & { queryKey: QueryKey }
}

export type GetExamQuestionCorrectRatesQueryResult = NonNullable<Awaited<ReturnType<typeof getExamQuestionCorrectRates>>>
export type GetExamQuestionCorrectRatesQueryError = AxiosError<unknown>


/**
 * @summary ê°•ì‚¬ìš©: íŠ¹ì • ì‹œí—˜ ë¬¸í•­ë³„ ì •ë‹µë¥ 
 */

export function useGetExamQuestionCorrectRates<TData = Awaited<ReturnType<typeof getExamQuestionCorrectRates>>, TError = AxiosError<unknown>>(
 examId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getExamQuestionCorrectRates>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetExamQuestionCorrectRatesQueryOptions(examId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary ê°•ì‚¬ìš©: ê°•ì˜ ì „ì²´ ë¬¸í•­ë³„ ì •ë‹µë¥ 
 */
export const getLectureQuestionCorrectRates = (
    lectureId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<QuestionCorrectRateResponse[]>> => {
    
    
    return axios.default.get(
      `/api/statistics/lectures/${lectureId}/questions`,options
    );
  }




export const getGetLectureQuestionCorrectRatesQueryKey = (lectureId?: number,) => {
    return [
    `/api/statistics/lectures/${lectureId}/questions`
    ] as const;
    }

    
export const getGetLectureQuestionCorrectRatesQueryOptions = <TData = Awaited<ReturnType<typeof getLectureQuestionCorrectRates>>, TError = AxiosError<unknown>>(lectureId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getLectureQuestionCorrectRates>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetLectureQuestionCorrectRatesQueryKey(lectureId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getLectureQuestionCorrectRates>>> = ({ signal }) => getLectureQuestionCorrectRates(lectureId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(lectureId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getLectureQuestionCorrectRates>>, TError, TData> & { queryKey: QueryKey }
}

export type GetLectureQuestionCorrectRatesQueryResult = NonNullable<Awaited<ReturnType<typeof getLectureQuestionCorrectRates>>>
export type GetLectureQuestionCorrectRatesQueryError = AxiosError<unknown>


/**
 * @summary ê°•ì‚¬ìš©: ê°•ì˜ ì „ì²´ ë¬¸í•­ë³„ ì •ë‹µë¥ 
 */

export function useGetLectureQuestionCorrectRates<TData = Awaited<ReturnType<typeof getLectureQuestionCorrectRates>>, TError = AxiosError<unknown>>(
 lectureId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getLectureQuestionCorrectRates>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetLectureQuestionCorrectRatesQueryOptions(lectureId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary ì‚¬ìš©ì ê²€ìƒ‰
 */
export const searchUsers = (
    academyId: number,
    params?: SearchUsersParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserSearchResultResponse[]>> => {
    
    
    return axios.default.get(
      `/api/academies/${academyId}/users/search`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getSearchUsersQueryKey = (academyId?: number,
    params?: SearchUsersParams,) => {
    return [
    `/api/academies/${academyId}/users/search`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getSearchUsersQueryOptions = <TData = Awaited<ReturnType<typeof searchUsers>>, TError = AxiosError<unknown>>(academyId: number,
    params?: SearchUsersParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof searchUsers>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchUsersQueryKey(academyId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchUsers>>> = ({ signal }) => searchUsers(academyId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(academyId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof searchUsers>>, TError, TData> & { queryKey: QueryKey }
}

export type SearchUsersQueryResult = NonNullable<Awaited<ReturnType<typeof searchUsers>>>
export type SearchUsersQueryError = AxiosError<unknown>


/**
 * @summary ì‚¬ìš©ì ê²€ìƒ‰
 */

export function useSearchUsers<TData = Awaited<ReturnType<typeof searchUsers>>, TError = AxiosError<unknown>>(
 academyId: number,
    params?: SearchUsersParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof searchUsers>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getSearchUsersQueryOptions(academyId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary í•™ìƒì„ ê°•ì‚¬ë¡œ ì—­í•  ë³€ê²½
 */
export const changeStudentToTeacher = (
    academyId: number,
    userId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    
    
    return axios.default.patch(
      `/api/academies/${academyId}/users/${userId}/role/teacher`,undefined,{
    ...options,}
    );
  }



export const getChangeStudentToTeacherMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof changeStudentToTeacher>>, TError,{academyId: number;userId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof changeStudentToTeacher>>, TError,{academyId: number;userId: number}, TContext> => {

const mutationKey = ['changeStudentToTeacher'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof changeStudentToTeacher>>, {academyId: number;userId: number}> = (props) => {
          const {academyId,userId} = props ?? {};

          return  changeStudentToTeacher(academyId,userId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ChangeStudentToTeacherMutationResult = NonNullable<Awaited<ReturnType<typeof changeStudentToTeacher>>>
    
    export type ChangeStudentToTeacherMutationError = AxiosError<unknown>

    /**
 * @summary í•™ìƒì„ ê°•ì‚¬ë¡œ ì—­í•  ë³€ê²½
 */
export const useChangeStudentToTeacher = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof changeStudentToTeacher>>, TError,{academyId: number;userId: number}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof changeStudentToTeacher>>,
        TError,
        {academyId: number;userId: number},
        TContext
      > => {

      const mutationOptions = getChangeStudentToTeacherMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary ì›ì¥(í•™ì›) íšŒì›ê°€ì…
 */
export const principalSignup = (
    principalRegistrationRequest: PrincipalRegistrationRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PrincipalRegistrationResponse>> => {
    
    
    return axios.default.post(
      `/api/academy/signup`,
      principalRegistrationRequest,options
    );
  }



export const getPrincipalSignupMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof principalSignup>>, TError,{data: PrincipalRegistrationRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof principalSignup>>, TError,{data: PrincipalRegistrationRequest}, TContext> => {

const mutationKey = ['principalSignup'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof principalSignup>>, {data: PrincipalRegistrationRequest}> = (props) => {
          const {data} = props ?? {};

          return  principalSignup(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PrincipalSignupMutationResult = NonNullable<Awaited<ReturnType<typeof principalSignup>>>
    export type PrincipalSignupMutationBody = PrincipalRegistrationRequest
    export type PrincipalSignupMutationError = AxiosError<unknown>

    /**
 * @summary ì›ì¥(í•™ì›) íšŒì›ê°€ì…
 */
export const usePrincipalSignup = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof principalSignup>>, TError,{data: PrincipalRegistrationRequest}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof principalSignup>>,
        TError,
        {data: PrincipalRegistrationRequest},
        TContext
      > => {

      const mutationOptions = getPrincipalSignupMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary ê°•ì˜ ìƒì„±
 */
export const createLecture = (
    lectureCreationRequest: LectureCreationRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<LectureCreationResponse>> => {
    
    
    return axios.default.post(
      `/api/lectures`,
      lectureCreationRequest,options
    );
  }



export const getCreateLectureMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createLecture>>, TError,{data: LectureCreationRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createLecture>>, TError,{data: LectureCreationRequest}, TContext> => {

const mutationKey = ['createLecture'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createLecture>>, {data: LectureCreationRequest}> = (props) => {
          const {data} = props ?? {};

          return  createLecture(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateLectureMutationResult = NonNullable<Awaited<ReturnType<typeof createLecture>>>
    export type CreateLectureMutationBody = LectureCreationRequest
    export type CreateLectureMutationError = AxiosError<unknown>

    /**
 * @summary ê°•ì˜ ìƒì„±
 */
export const useCreateLecture = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createLecture>>, TError,{data: LectureCreationRequest}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof createLecture>>,
        TError,
        {data: LectureCreationRequest},
        TContext
      > => {

      const mutationOptions = getCreateLectureMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary ê°•ì˜ ëª©ë¡ ì¡°íšŒ (ì„ ìƒ/ì›ì¥)
 */
export const getLecturesByTeacher = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<LectureForTeacherResponse[]>> => {
    
    
    return axios.default.get(
      `/api/lectures`,options
    );
  }




export const getGetLecturesByTeacherQueryKey = () => {
    return [
    `/api/lectures`
    ] as const;
    }

    
export const getGetLecturesByTeacherQueryOptions = <TData = Awaited<ReturnType<typeof getLecturesByTeacher>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getLecturesByTeacher>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetLecturesByTeacherQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getLecturesByTeacher>>> = ({ signal }) => getLecturesByTeacher({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getLecturesByTeacher>>, TError, TData> & { queryKey: QueryKey }
}

export type GetLecturesByTeacherQueryResult = NonNullable<Awaited<ReturnType<typeof getLecturesByTeacher>>>
export type GetLecturesByTeacherQueryError = AxiosError<unknown>


/**
 * @summary ê°•ì˜ ëª©ë¡ ì¡°íšŒ (ì„ ìƒ/ì›ì¥)
 */

export function useGetLecturesByTeacher<TData = Awaited<ReturnType<typeof getLecturesByTeacher>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getLecturesByTeacher>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetLecturesByTeacherQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary ê°•ì˜ ìƒì„¸ ì¡°íšŒ (ì„ ìƒ/ì›ì¥) - í†µê³„ í¬í•¨
 */
export const getLectureDetailForTeacher = (
    lectureId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<LectureDetailWithStatisticsResponse>> => {
    
    
    return axios.default.get(
      `/api/lectures/${lectureId}`,options
    );
  }




export const getGetLectureDetailForTeacherQueryKey = (lectureId?: number,) => {
    return [
    `/api/lectures/${lectureId}`
    ] as const;
    }

    
export const getGetLectureDetailForTeacherQueryOptions = <TData = Awaited<ReturnType<typeof getLectureDetailForTeacher>>, TError = AxiosError<unknown>>(lectureId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getLectureDetailForTeacher>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetLectureDetailForTeacherQueryKey(lectureId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getLectureDetailForTeacher>>> = ({ signal }) => getLectureDetailForTeacher(lectureId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(lectureId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getLectureDetailForTeacher>>, TError, TData> & { queryKey: QueryKey }
}

export type GetLectureDetailForTeacherQueryResult = NonNullable<Awaited<ReturnType<typeof getLectureDetailForTeacher>>>
export type GetLectureDetailForTeacherQueryError = AxiosError<unknown>


/**
 * @summary ê°•ì˜ ìƒì„¸ ì¡°íšŒ (ì„ ìƒ/ì›ì¥) - í†µê³„ í¬í•¨
 */

export function useGetLectureDetailForTeacher<TData = Awaited<ReturnType<typeof getLectureDetailForTeacher>>, TError = AxiosError<unknown>>(
 lectureId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getLectureDetailForTeacher>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetLectureDetailForTeacherQueryOptions(lectureId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary ê°•ì˜ë¥¼ ë“£ëŠ” í•™ìƒ ëª©ë¡ ì¡°íšŒ
 */
export const getStudentsByLecture = (
    lectureId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<StudentSearchResponse[]>> => {
    
    
    return axios.default.get(
      `/api/lectures/${lectureId}/students`,options
    );
  }




export const getGetStudentsByLectureQueryKey = (lectureId?: number,) => {
    return [
    `/api/lectures/${lectureId}/students`
    ] as const;
    }

    
export const getGetStudentsByLectureQueryOptions = <TData = Awaited<ReturnType<typeof getStudentsByLecture>>, TError = AxiosError<unknown>>(lectureId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getStudentsByLecture>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStudentsByLectureQueryKey(lectureId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStudentsByLecture>>> = ({ signal }) => getStudentsByLecture(lectureId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(lectureId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getStudentsByLecture>>, TError, TData> & { queryKey: QueryKey }
}

export type GetStudentsByLectureQueryResult = NonNullable<Awaited<ReturnType<typeof getStudentsByLecture>>>
export type GetStudentsByLectureQueryError = AxiosError<unknown>


/**
 * @summary ê°•ì˜ë¥¼ ë“£ëŠ” í•™ìƒ ëª©ë¡ ì¡°íšŒ
 */

export function useGetStudentsByLecture<TData = Awaited<ReturnType<typeof getStudentsByLecture>>, TError = AxiosError<unknown>>(
 lectureId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getStudentsByLecture>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetStudentsByLectureQueryOptions(lectureId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary ê°•ì˜ì— í•™ìƒ ë°°ì •
 */
export const assignStudentsToLecture = (
    lectureId: number,
    lectureStudentAssignRequest: LectureStudentAssignRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<LectureStudentAssignResponse>> => {
    
    
    return axios.default.post(
      `/api/lectures/${lectureId}/students`,
      lectureStudentAssignRequest,options
    );
  }



export const getAssignStudentsToLectureMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof assignStudentsToLecture>>, TError,{lectureId: number;data: LectureStudentAssignRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof assignStudentsToLecture>>, TError,{lectureId: number;data: LectureStudentAssignRequest}, TContext> => {

const mutationKey = ['assignStudentsToLecture'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof assignStudentsToLecture>>, {lectureId: number;data: LectureStudentAssignRequest}> = (props) => {
          const {lectureId,data} = props ?? {};

          return  assignStudentsToLecture(lectureId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AssignStudentsToLectureMutationResult = NonNullable<Awaited<ReturnType<typeof assignStudentsToLecture>>>
    export type AssignStudentsToLectureMutationBody = LectureStudentAssignRequest
    export type AssignStudentsToLectureMutationError = AxiosError<unknown>

    /**
 * @summary ê°•ì˜ì— í•™ìƒ ë°°ì •
 */
export const useAssignStudentsToLecture = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof assignStudentsToLecture>>, TError,{lectureId: number;data: LectureStudentAssignRequest}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof assignStudentsToLecture>>,
        TError,
        {lectureId: number;data: LectureStudentAssignRequest},
        TContext
      > => {

      const mutationOptions = getAssignStudentsToLectureMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary ê°•ì˜ì— ë°°ì •ë˜ì§€ ì•Šì€ í•™ìƒ ê²€ìƒ‰
 */
export const getAvailableStudentsForLecture = (
    lectureId: number,
    params: GetAvailableStudentsForLectureParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<StudentSearchResponse[]>> => {
    
    
    return axios.default.get(
      `/api/lectures/${lectureId}/available-students`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getGetAvailableStudentsForLectureQueryKey = (lectureId?: number,
    params?: GetAvailableStudentsForLectureParams,) => {
    return [
    `/api/lectures/${lectureId}/available-students`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetAvailableStudentsForLectureQueryOptions = <TData = Awaited<ReturnType<typeof getAvailableStudentsForLecture>>, TError = AxiosError<unknown>>(lectureId: number,
    params: GetAvailableStudentsForLectureParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAvailableStudentsForLecture>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAvailableStudentsForLectureQueryKey(lectureId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAvailableStudentsForLecture>>> = ({ signal }) => getAvailableStudentsForLecture(lectureId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(lectureId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAvailableStudentsForLecture>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAvailableStudentsForLectureQueryResult = NonNullable<Awaited<ReturnType<typeof getAvailableStudentsForLecture>>>
export type GetAvailableStudentsForLectureQueryError = AxiosError<unknown>


/**
 * @summary ê°•ì˜ì— ë°°ì •ë˜ì§€ ì•Šì€ í•™ìƒ ê²€ìƒ‰
 */

export function useGetAvailableStudentsForLecture<TData = Awaited<ReturnType<typeof getAvailableStudentsForLecture>>, TError = AxiosError<unknown>>(
 lectureId: number,
    params: GetAvailableStudentsForLectureParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAvailableStudentsForLecture>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAvailableStudentsForLectureQueryOptions(lectureId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * ê°•ì˜ ë‹¨ìœ„ ì „ì²´ í†µê³„ ì¡°íšŒ (ìˆ˜ê°•ìƒ ìˆ˜, ì¶œì„ë¥ , ê³¼ì œ ì œì¶œë¥ , ì‹œí—˜ ì‘ì‹œìœ¨, í‰ê·  ì„±ì , ìƒìœ„ 10% í‰ê·  ì„±ì )
 * @summary ê°•ì˜ í†µê³„ ì¡°íšŒ
 */
export const getLectureStatistics = (
    lectureId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<LectureStatisticsResponse>> => {
    
    
    return axios.default.get(
      `/api/lectures/${lectureId}/statistics`,options
    );
  }




export const getGetLectureStatisticsQueryKey = (lectureId?: number,) => {
    return [
    `/api/lectures/${lectureId}/statistics`
    ] as const;
    }

    
export const getGetLectureStatisticsQueryOptions = <TData = Awaited<ReturnType<typeof getLectureStatistics>>, TError = AxiosError<void>>(lectureId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getLectureStatistics>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetLectureStatisticsQueryKey(lectureId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getLectureStatistics>>> = ({ signal }) => getLectureStatistics(lectureId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(lectureId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getLectureStatistics>>, TError, TData> & { queryKey: QueryKey }
}

export type GetLectureStatisticsQueryResult = NonNullable<Awaited<ReturnType<typeof getLectureStatistics>>>
export type GetLectureStatisticsQueryError = AxiosError<void>


/**
 * @summary ê°•ì˜ í†µê³„ ì¡°íšŒ
 */

export function useGetLectureStatistics<TData = Awaited<ReturnType<typeof getLectureStatistics>>, TError = AxiosError<void>>(
 lectureId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getLectureStatistics>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetLectureStatisticsQueryOptions(lectureId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * íŠ¹ì • ê°•ì˜ì˜ ì „ì²´ ìˆ˜ê°•ìƒ ë‹¨ì›ë³„ ì •ë‹µë¥  ì¡°íšŒ (í•™ìƒ ë¦¬í¬íŠ¸ì—ì„œ ë³¸ì¸ ì •ë‹µë¥ ê³¼ ì „ì²´ í‰ê·  ë¹„êµìš©)
 * @summary ê°•ì˜ ë‹¨ì›ë³„ ì •ë‹µë¥  ì¡°íšŒ
 */
export const getLectureUnitCorrectRates = (
    lectureId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UnitCorrectRateResponse[]>> => {
    
    
    return axios.default.get(
      `/api/lectures/${lectureId}/unit-correct-rates`,options
    );
  }




export const getGetLectureUnitCorrectRatesQueryKey = (lectureId?: number,) => {
    return [
    `/api/lectures/${lectureId}/unit-correct-rates`
    ] as const;
    }

    
export const getGetLectureUnitCorrectRatesQueryOptions = <TData = Awaited<ReturnType<typeof getLectureUnitCorrectRates>>, TError = AxiosError<void>>(lectureId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getLectureUnitCorrectRates>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetLectureUnitCorrectRatesQueryKey(lectureId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getLectureUnitCorrectRates>>> = ({ signal }) => getLectureUnitCorrectRates(lectureId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(lectureId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getLectureUnitCorrectRates>>, TError, TData> & { queryKey: QueryKey }
}

export type GetLectureUnitCorrectRatesQueryResult = NonNullable<Awaited<ReturnType<typeof getLectureUnitCorrectRates>>>
export type GetLectureUnitCorrectRatesQueryError = AxiosError<void>


/**
 * @summary ê°•ì˜ ë‹¨ì›ë³„ ì •ë‹µë¥  ì¡°íšŒ
 */

export function useGetLectureUnitCorrectRates<TData = Awaited<ReturnType<typeof getLectureUnitCorrectRates>>, TError = AxiosError<void>>(
 lectureId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getLectureUnitCorrectRates>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetLectureUnitCorrectRatesQueryOptions(lectureId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary ê³¼ì œ ìƒì„±
 */
export const createAssignment = (
    academyId: number,
    lectureId: number,
    assignmentCreateRequest: AssignmentCreateRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AssignmentCreateResponse>> => {
    
    
    return axios.default.post(
      `/api/academies/${academyId}/lectures/${lectureId}/assignments`,
      assignmentCreateRequest,options
    );
  }



export const getCreateAssignmentMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAssignment>>, TError,{academyId: number;lectureId: number;data: AssignmentCreateRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createAssignment>>, TError,{academyId: number;lectureId: number;data: AssignmentCreateRequest}, TContext> => {

const mutationKey = ['createAssignment'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createAssignment>>, {academyId: number;lectureId: number;data: AssignmentCreateRequest}> = (props) => {
          const {academyId,lectureId,data} = props ?? {};

          return  createAssignment(academyId,lectureId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateAssignmentMutationResult = NonNullable<Awaited<ReturnType<typeof createAssignment>>>
    export type CreateAssignmentMutationBody = AssignmentCreateRequest
    export type CreateAssignmentMutationError = AxiosError<unknown>

    /**
 * @summary ê³¼ì œ ìƒì„±
 */
export const useCreateAssignment = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAssignment>>, TError,{academyId: number;lectureId: number;data: AssignmentCreateRequest}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof createAssignment>>,
        TError,
        {academyId: number;lectureId: number;data: AssignmentCreateRequest},
        TContext
      > => {

      const mutationOptions = getCreateAssignmentMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary í•™ìƒìš© - íŠ¹ì • ê°•ì˜ì˜ ê³¼ì œ ë¦¬ìŠ¤íŠ¸ ì¡°íšŒ
 */
export const getAssignmentsForLecture = (
    academyId: number,
    lectureId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AssignmentListResponse[]>> => {
    
    
    return axios.default.get(
      `/api/academies/${academyId}/lectures/${lectureId}/assignments/list`,options
    );
  }




export const getGetAssignmentsForLectureQueryKey = (academyId?: number,
    lectureId?: number,) => {
    return [
    `/api/academies/${academyId}/lectures/${lectureId}/assignments/list`
    ] as const;
    }

    
export const getGetAssignmentsForLectureQueryOptions = <TData = Awaited<ReturnType<typeof getAssignmentsForLecture>>, TError = AxiosError<unknown>>(academyId: number,
    lectureId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssignmentsForLecture>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssignmentsForLectureQueryKey(academyId,lectureId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssignmentsForLecture>>> = ({ signal }) => getAssignmentsForLecture(academyId,lectureId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(academyId && lectureId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAssignmentsForLecture>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAssignmentsForLectureQueryResult = NonNullable<Awaited<ReturnType<typeof getAssignmentsForLecture>>>
export type GetAssignmentsForLectureQueryError = AxiosError<unknown>


/**
 * @summary í•™ìƒìš© - íŠ¹ì • ê°•ì˜ì˜ ê³¼ì œ ë¦¬ìŠ¤íŠ¸ ì¡°íšŒ
 */

export function useGetAssignmentsForLecture<TData = Awaited<ReturnType<typeof getAssignmentsForLecture>>, TError = AxiosError<unknown>>(
 academyId: number,
    lectureId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssignmentsForLecture>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAssignmentsForLectureQueryOptions(academyId,lectureId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary í•™ìƒìš© - ìì‹ ì˜ ê³¼ì œ ì œì¶œ ìƒì„¸ ì¡°íšŒ
 */
export const getMySubmission = (
    academyId: number,
    assignmentId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AssignmentSubmissionStudentViewResponse>> => {
    
    
    return axios.default.get(
      `/api/academies/${academyId}/assignments/${assignmentId}/submissions/my-submission`,options
    );
  }




export const getGetMySubmissionQueryKey = (academyId?: number,
    assignmentId?: number,) => {
    return [
    `/api/academies/${academyId}/assignments/${assignmentId}/submissions/my-submission`
    ] as const;
    }

    
export const getGetMySubmissionQueryOptions = <TData = Awaited<ReturnType<typeof getMySubmission>>, TError = AxiosError<unknown>>(academyId: number,
    assignmentId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMySubmission>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMySubmissionQueryKey(academyId,assignmentId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMySubmission>>> = ({ signal }) => getMySubmission(academyId,assignmentId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(academyId && assignmentId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMySubmission>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMySubmissionQueryResult = NonNullable<Awaited<ReturnType<typeof getMySubmission>>>
export type GetMySubmissionQueryError = AxiosError<unknown>


/**
 * @summary í•™ìƒìš© - ìì‹ ì˜ ê³¼ì œ ì œì¶œ ìƒì„¸ ì¡°íšŒ
 */

export function useGetMySubmission<TData = Awaited<ReturnType<typeof getMySubmission>>, TError = AxiosError<unknown>>(
 academyId: number,
    assignmentId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMySubmission>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetMySubmissionQueryOptions(academyId,assignmentId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary ê³¼ì œ ì œì¶œìš© Presigned URL ë°œê¸‰
 */
export const getAssignmentPresignedUrl = (
    assignmentId: number,
    presignedUrlRequest: PresignedUrlRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PresignedUrlResponse>> => {
    
    
    return axios.default.post(
      `/api/assignments/${assignmentId}/presigned-url`,
      presignedUrlRequest,options
    );
  }



export const getGetAssignmentPresignedUrlMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getAssignmentPresignedUrl>>, TError,{assignmentId: number;data: PresignedUrlRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof getAssignmentPresignedUrl>>, TError,{assignmentId: number;data: PresignedUrlRequest}, TContext> => {

const mutationKey = ['getAssignmentPresignedUrl'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof getAssignmentPresignedUrl>>, {assignmentId: number;data: PresignedUrlRequest}> = (props) => {
          const {assignmentId,data} = props ?? {};

          return  getAssignmentPresignedUrl(assignmentId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GetAssignmentPresignedUrlMutationResult = NonNullable<Awaited<ReturnType<typeof getAssignmentPresignedUrl>>>
    export type GetAssignmentPresignedUrlMutationBody = PresignedUrlRequest
    export type GetAssignmentPresignedUrlMutationError = AxiosError<unknown>

    /**
 * @summary ê³¼ì œ ì œì¶œìš© Presigned URL ë°œê¸‰
 */
export const useGetAssignmentPresignedUrl = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getAssignmentPresignedUrl>>, TError,{assignmentId: number;data: PresignedUrlRequest}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof getAssignmentPresignedUrl>>,
        TError,
        {assignmentId: number;data: PresignedUrlRequest},
        TContext
      > => {

      const mutationOptions = getGetAssignmentPresignedUrlMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary ê³¼ì œ ì œì¶œ
 */
export const submitAssignment = (
    assignmentId: number,
    assignmentSubmitRequest: AssignmentSubmitRequest,
    params: SubmitAssignmentParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AssignmentSubmitResponse>> => {
    
    
    return axios.default.post(
      `/api/assignments/${assignmentId}/submit`,
      assignmentSubmitRequest,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getSubmitAssignmentMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof submitAssignment>>, TError,{assignmentId: number;data: AssignmentSubmitRequest;params: SubmitAssignmentParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof submitAssignment>>, TError,{assignmentId: number;data: AssignmentSubmitRequest;params: SubmitAssignmentParams}, TContext> => {

const mutationKey = ['submitAssignment'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof submitAssignment>>, {assignmentId: number;data: AssignmentSubmitRequest;params: SubmitAssignmentParams}> = (props) => {
          const {assignmentId,data,params} = props ?? {};

          return  submitAssignment(assignmentId,data,params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SubmitAssignmentMutationResult = NonNullable<Awaited<ReturnType<typeof submitAssignment>>>
    export type SubmitAssignmentMutationBody = AssignmentSubmitRequest
    export type SubmitAssignmentMutationError = AxiosError<unknown>

    /**
 * @summary ê³¼ì œ ì œì¶œ
 */
export const useSubmitAssignment = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof submitAssignment>>, TError,{assignmentId: number;data: AssignmentSubmitRequest;params: SubmitAssignmentParams}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof submitAssignment>>,
        TError,
        {assignmentId: number;data: AssignmentSubmitRequest;params: SubmitAssignmentParams},
        TContext
      > => {

      const mutationOptions = getSubmitAssignmentMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary ê°•ì‚¬ìš© - íŠ¹ì • ê³¼ì œ ì œì¶œ ë¦¬ìŠ¤íŠ¸ ì¡°íšŒ
 */
export const getSubmissions = (
    academyId: number,
    assignmentId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AssignmentSubmissionListResponse[]>> => {
    
    
    return axios.default.get(
      `/api/academies/${academyId}/assignments/${assignmentId}/submissions`,options
    );
  }




export const getGetSubmissionsQueryKey = (academyId?: number,
    assignmentId?: number,) => {
    return [
    `/api/academies/${academyId}/assignments/${assignmentId}/submissions`
    ] as const;
    }

    
export const getGetSubmissionsQueryOptions = <TData = Awaited<ReturnType<typeof getSubmissions>>, TError = AxiosError<unknown>>(academyId: number,
    assignmentId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getSubmissions>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSubmissionsQueryKey(academyId,assignmentId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSubmissions>>> = ({ signal }) => getSubmissions(academyId,assignmentId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(academyId && assignmentId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSubmissions>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSubmissionsQueryResult = NonNullable<Awaited<ReturnType<typeof getSubmissions>>>
export type GetSubmissionsQueryError = AxiosError<unknown>


/**
 * @summary ê°•ì‚¬ìš© - íŠ¹ì • ê³¼ì œ ì œì¶œ ë¦¬ìŠ¤íŠ¸ ì¡°íšŒ
 */

export function useGetSubmissions<TData = Awaited<ReturnType<typeof getSubmissions>>, TError = AxiosError<unknown>>(
 academyId: number,
    assignmentId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getSubmissions>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetSubmissionsQueryOptions(academyId,assignmentId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary ê°•ì‚¬ìš© - ê³¼ì œ ì œì¶œ ìƒì„¸ ì¡°íšŒ
 */
export const getSubmissionForTeacher = (
    academyId: number,
    assignmentId: number,
    submissionId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AssignmentSubmissionTeacherViewResponse>> => {
    
    
    return axios.default.get(
      `/api/academies/${academyId}/assignments/${assignmentId}/submissions/${submissionId}`,options
    );
  }




export const getGetSubmissionForTeacherQueryKey = (academyId?: number,
    assignmentId?: number,
    submissionId?: number,) => {
    return [
    `/api/academies/${academyId}/assignments/${assignmentId}/submissions/${submissionId}`
    ] as const;
    }

    
export const getGetSubmissionForTeacherQueryOptions = <TData = Awaited<ReturnType<typeof getSubmissionForTeacher>>, TError = AxiosError<unknown>>(academyId: number,
    assignmentId: number,
    submissionId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getSubmissionForTeacher>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSubmissionForTeacherQueryKey(academyId,assignmentId,submissionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSubmissionForTeacher>>> = ({ signal }) => getSubmissionForTeacher(academyId,assignmentId,submissionId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(academyId && assignmentId && submissionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSubmissionForTeacher>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSubmissionForTeacherQueryResult = NonNullable<Awaited<ReturnType<typeof getSubmissionForTeacher>>>
export type GetSubmissionForTeacherQueryError = AxiosError<unknown>


/**
 * @summary ê°•ì‚¬ìš© - ê³¼ì œ ì œì¶œ ìƒì„¸ ì¡°íšŒ
 */

export function useGetSubmissionForTeacher<TData = Awaited<ReturnType<typeof getSubmissionForTeacher>>, TError = AxiosError<unknown>>(
 academyId: number,
    assignmentId: number,
    submissionId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getSubmissionForTeacher>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetSubmissionForTeacherQueryOptions(academyId,assignmentId,submissionId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary ê°•ì‚¬ìš© - ì ìˆ˜ ë° í”¼ë“œë°± ì €ì¥
 */
export const gradeSubmission = (
    academyId: number,
    assignmentId: number,
    submissionId: number,
    assignmentGradeRequest: AssignmentGradeRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AssignmentGradeResponse>> => {
    
    
    return axios.default.patch(
      `/api/academies/${academyId}/assignments/${assignmentId}/submissions/${submissionId}/grade`,
      assignmentGradeRequest,options
    );
  }



export const getGradeSubmissionMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof gradeSubmission>>, TError,{academyId: number;assignmentId: number;submissionId: number;data: AssignmentGradeRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof gradeSubmission>>, TError,{academyId: number;assignmentId: number;submissionId: number;data: AssignmentGradeRequest}, TContext> => {

const mutationKey = ['gradeSubmission'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof gradeSubmission>>, {academyId: number;assignmentId: number;submissionId: number;data: AssignmentGradeRequest}> = (props) => {
          const {academyId,assignmentId,submissionId,data} = props ?? {};

          return  gradeSubmission(academyId,assignmentId,submissionId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GradeSubmissionMutationResult = NonNullable<Awaited<ReturnType<typeof gradeSubmission>>>
    export type GradeSubmissionMutationBody = AssignmentGradeRequest
    export type GradeSubmissionMutationError = AxiosError<unknown>

    /**
 * @summary ê°•ì‚¬ìš© - ì ìˆ˜ ë° í”¼ë“œë°± ì €ì¥
 */
export const useGradeSubmission = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof gradeSubmission>>, TError,{academyId: number;assignmentId: number;submissionId: number;data: AssignmentGradeRequest}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof gradeSubmission>>,
        TError,
        {academyId: number;assignmentId: number;submissionId: number;data: AssignmentGradeRequest},
        TContext
      > => {

      const mutationOptions = getGradeSubmissionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary ì‹œí—˜ ìƒì„±
 */
export const createExam = (
    lectureId: number,
    examCreationRequest: ExamCreationRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ExamCreationResponse>> => {
    
    
    return axios.default.post(
      `/api/lectures/${lectureId}/exams`,
      examCreationRequest,options
    );
  }



export const getCreateExamMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createExam>>, TError,{lectureId: number;data: ExamCreationRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createExam>>, TError,{lectureId: number;data: ExamCreationRequest}, TContext> => {

const mutationKey = ['createExam'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createExam>>, {lectureId: number;data: ExamCreationRequest}> = (props) => {
          const {lectureId,data} = props ?? {};

          return  createExam(lectureId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateExamMutationResult = NonNullable<Awaited<ReturnType<typeof createExam>>>
    export type CreateExamMutationBody = ExamCreationRequest
    export type CreateExamMutationError = AxiosError<unknown>

    /**
 * @summary ì‹œí—˜ ìƒì„±
 */
export const useCreateExam = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createExam>>, TError,{lectureId: number;data: ExamCreationRequest}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof createExam>>,
        TError,
        {lectureId: number;data: ExamCreationRequest},
        TContext
      > => {

      const mutationOptions = getCreateExamMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary ì‹œí—˜ ë¬¸ì œ ë“±ë¡
 */
export const registerExamQuestions = (
    lectureId: number,
    examId: number,
    questionRegistrationRequest: QuestionRegistrationRequest[], options?: AxiosRequestConfig
 ): Promise<AxiosResponse<QuestionIdResponse[]>> => {
    
    
    return axios.default.post(
      `/api/lectures/${lectureId}/exams/${examId}/mcq`,
      questionRegistrationRequest,options
    );
  }



export const getRegisterExamQuestionsMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registerExamQuestions>>, TError,{lectureId: number;examId: number;data: QuestionRegistrationRequest[]}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof registerExamQuestions>>, TError,{lectureId: number;examId: number;data: QuestionRegistrationRequest[]}, TContext> => {

const mutationKey = ['registerExamQuestions'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof registerExamQuestions>>, {lectureId: number;examId: number;data: QuestionRegistrationRequest[]}> = (props) => {
          const {lectureId,examId,data} = props ?? {};

          return  registerExamQuestions(lectureId,examId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RegisterExamQuestionsMutationResult = NonNullable<Awaited<ReturnType<typeof registerExamQuestions>>>
    export type RegisterExamQuestionsMutationBody = QuestionRegistrationRequest[]
    export type RegisterExamQuestionsMutationError = AxiosError<unknown>

    /**
 * @summary ì‹œí—˜ ë¬¸ì œ ë“±ë¡
 */
export const useRegisterExamQuestions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registerExamQuestions>>, TError,{lectureId: number;examId: number;data: QuestionRegistrationRequest[]}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof registerExamQuestions>>,
        TError,
        {lectureId: number;examId: number;data: QuestionRegistrationRequest[]},
        TContext
      > => {

      const mutationOptions = getRegisterExamQuestionsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary ì‹œí—˜ ìƒì„¸ ì¡°íšŒ
 */
export const getExamDetail = (
    lectureId: number,
    examId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ExamDetailResponse>> => {
    
    
    return axios.default.get(
      `/api/lectures/${lectureId}/exams/${examId}`,options
    );
  }




export const getGetExamDetailQueryKey = (lectureId?: number,
    examId?: number,) => {
    return [
    `/api/lectures/${lectureId}/exams/${examId}`
    ] as const;
    }

    
export const getGetExamDetailQueryOptions = <TData = Awaited<ReturnType<typeof getExamDetail>>, TError = AxiosError<unknown>>(lectureId: number,
    examId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getExamDetail>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetExamDetailQueryKey(lectureId,examId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getExamDetail>>> = ({ signal }) => getExamDetail(lectureId,examId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(lectureId && examId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getExamDetail>>, TError, TData> & { queryKey: QueryKey }
}

export type GetExamDetailQueryResult = NonNullable<Awaited<ReturnType<typeof getExamDetail>>>
export type GetExamDetailQueryError = AxiosError<unknown>


/**
 * @summary ì‹œí—˜ ìƒì„¸ ì¡°íšŒ
 */

export function useGetExamDetail<TData = Awaited<ReturnType<typeof getExamDetail>>, TError = AxiosError<unknown>>(
 lectureId: number,
    examId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getExamDetail>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetExamDetailQueryOptions(lectureId,examId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary ì‹œí—˜ ì‘ì‹œ ì‹œì‘
 */
export const startExam = (
    examId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ExamStartResponse>> => {
    
    
    return axios.default.post(
      `/api/student/exams/${examId}/start`,undefined,options
    );
  }



export const getStartExamMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof startExam>>, TError,{examId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof startExam>>, TError,{examId: number}, TContext> => {

const mutationKey = ['startExam'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof startExam>>, {examId: number}> = (props) => {
          const {examId} = props ?? {};

          return  startExam(examId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type StartExamMutationResult = NonNullable<Awaited<ReturnType<typeof startExam>>>
    
    export type StartExamMutationError = AxiosError<unknown>

    /**
 * @summary ì‹œí—˜ ì‘ì‹œ ì‹œì‘
 */
export const useStartExam = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof startExam>>, TError,{examId: number}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof startExam>>,
        TError,
        {examId: number},
        TContext
      > => {

      const mutationOptions = getStartExamMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary ë‹µì•ˆ ì €ì¥ (ìë™/ìˆ˜ë™ ì €ì¥)
 */
export const saveAnswers = (
    examId: number,
    answerSaveRequest: AnswerSaveRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AnswerSaveResponse>> => {
    
    
    return axios.default.post(
      `/api/student/exams/${examId}/answers`,
      answerSaveRequest,options
    );
  }



export const getSaveAnswersMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof saveAnswers>>, TError,{examId: number;data: AnswerSaveRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof saveAnswers>>, TError,{examId: number;data: AnswerSaveRequest}, TContext> => {

const mutationKey = ['saveAnswers'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof saveAnswers>>, {examId: number;data: AnswerSaveRequest}> = (props) => {
          const {examId,data} = props ?? {};

          return  saveAnswers(examId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SaveAnswersMutationResult = NonNullable<Awaited<ReturnType<typeof saveAnswers>>>
    export type SaveAnswersMutationBody = AnswerSaveRequest
    export type SaveAnswersMutationError = AxiosError<unknown>

    /**
 * @summary ë‹µì•ˆ ì €ì¥ (ìë™/ìˆ˜ë™ ì €ì¥)
 */
export const useSaveAnswers = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof saveAnswers>>, TError,{examId: number;data: AnswerSaveRequest}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof saveAnswers>>,
        TError,
        {examId: number;data: AnswerSaveRequest},
        TContext
      > => {

      const mutationOptions = getSaveAnswersMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary ì‹œí—˜ ì œì¶œ
 */
export const submitExam = (
    examId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ExamSubmitResponse>> => {
    
    
    return axios.default.post(
      `/api/student/exams/${examId}/submit`,undefined,options
    );
  }



export const getSubmitExamMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof submitExam>>, TError,{examId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof submitExam>>, TError,{examId: number}, TContext> => {

const mutationKey = ['submitExam'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof submitExam>>, {examId: number}> = (props) => {
          const {examId} = props ?? {};

          return  submitExam(examId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SubmitExamMutationResult = NonNullable<Awaited<ReturnType<typeof submitExam>>>
    
    export type SubmitExamMutationError = AxiosError<unknown>

    /**
 * @summary ì‹œí—˜ ì œì¶œ
 */
export const useSubmitExam = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof submitExam>>, TError,{examId: number}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof submitExam>>,
        TError,
        {examId: number},
        TContext
      > => {

      const mutationOptions = getSubmitExamMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary ì‹œí—˜ ê²°ê³¼ ì¡°íšŒ
 */
export const getExamResult = (
    examId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ExamResultResponse>> => {
    
    
    return axios.default.get(
      `/api/student/exams/${examId}/result`,options
    );
  }




export const getGetExamResultQueryKey = (examId?: number,) => {
    return [
    `/api/student/exams/${examId}/result`
    ] as const;
    }

    
export const getGetExamResultQueryOptions = <TData = Awaited<ReturnType<typeof getExamResult>>, TError = AxiosError<unknown>>(examId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getExamResult>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetExamResultQueryKey(examId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getExamResult>>> = ({ signal }) => getExamResult(examId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(examId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getExamResult>>, TError, TData> & { queryKey: QueryKey }
}

export type GetExamResultQueryResult = NonNullable<Awaited<ReturnType<typeof getExamResult>>>
export type GetExamResultQueryError = AxiosError<unknown>


/**
 * @summary ì‹œí—˜ ê²°ê³¼ ì¡°íšŒ
 */

export function useGetExamResult<TData = Awaited<ReturnType<typeof getExamResult>>, TError = AxiosError<unknown>>(
 examId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getExamResult>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetExamResultQueryOptions(examId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary ë‚´ ì‹œí—˜ ê¸°ë¡ ëª©ë¡ ì¡°íšŒ
 */
export const getExamRecords = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ExamRecordResponse[]>> => {
    
    
    return axios.default.get(
      `/api/student/exams/records`,options
    );
  }




export const getGetExamRecordsQueryKey = () => {
    return [
    `/api/student/exams/records`
    ] as const;
    }

    
export const getGetExamRecordsQueryOptions = <TData = Awaited<ReturnType<typeof getExamRecords>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getExamRecords>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetExamRecordsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getExamRecords>>> = ({ signal }) => getExamRecords({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getExamRecords>>, TError, TData> & { queryKey: QueryKey }
}

export type GetExamRecordsQueryResult = NonNullable<Awaited<ReturnType<typeof getExamRecords>>>
export type GetExamRecordsQueryError = AxiosError<unknown>


/**
 * @summary ë‚´ ì‹œí—˜ ê¸°ë¡ ëª©ë¡ ì¡°íšŒ
 */

export function useGetExamRecords<TData = Awaited<ReturnType<typeof getExamRecords>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getExamRecords>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetExamRecordsQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary ë‚´ ê°•ì˜ ëª©ë¡ ì¡°íšŒ
 */
export const getMyLectures = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MyLectureResponse[]>> => {
    
    
    return axios.default.get(
      `/api/student/lectures`,options
    );
  }




export const getGetMyLecturesQueryKey = () => {
    return [
    `/api/student/lectures`
    ] as const;
    }

    
export const getGetMyLecturesQueryOptions = <TData = Awaited<ReturnType<typeof getMyLectures>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMyLectures>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMyLecturesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyLectures>>> = ({ signal }) => getMyLectures({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMyLectures>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMyLecturesQueryResult = NonNullable<Awaited<ReturnType<typeof getMyLectures>>>
export type GetMyLecturesQueryError = AxiosError<unknown>


/**
 * @summary ë‚´ ê°•ì˜ ëª©ë¡ ì¡°íšŒ
 */

export function useGetMyLectures<TData = Awaited<ReturnType<typeof getMyLectures>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMyLectures>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetMyLecturesQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary ë‚´ ê°•ì˜ ìƒì„¸ ì¡°íšŒ
 */
export const getMyLectureDetail = (
    lectureId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MyLectureDetailResponse>> => {
    
    
    return axios.default.get(
      `/api/student/lectures/${lectureId}`,options
    );
  }




export const getGetMyLectureDetailQueryKey = (lectureId?: number,) => {
    return [
    `/api/student/lectures/${lectureId}`
    ] as const;
    }

    
export const getGetMyLectureDetailQueryOptions = <TData = Awaited<ReturnType<typeof getMyLectureDetail>>, TError = AxiosError<void>>(lectureId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMyLectureDetail>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMyLectureDetailQueryKey(lectureId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyLectureDetail>>> = ({ signal }) => getMyLectureDetail(lectureId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(lectureId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMyLectureDetail>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMyLectureDetailQueryResult = NonNullable<Awaited<ReturnType<typeof getMyLectureDetail>>>
export type GetMyLectureDetailQueryError = AxiosError<void>


/**
 * @summary ë‚´ ê°•ì˜ ìƒì„¸ ì¡°íšŒ
 */

export function useGetMyLectureDetail<TData = Awaited<ReturnType<typeof getMyLectureDetail>>, TError = AxiosError<void>>(
 lectureId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMyLectureDetail>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetMyLectureDetailQueryOptions(lectureId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary ì¶œì„ ì²´í¬
 */
export const checkIn = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AttendanceCheckInResponse>> => {
    
    
    return axios.default.post(
      `/api/student/attendance/check-in`,undefined,options
    );
  }



export const getCheckInMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkIn>>, TError,void, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof checkIn>>, TError,void, TContext> => {

const mutationKey = ['checkIn'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkIn>>, void> = () => {
          

          return  checkIn(axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckInMutationResult = NonNullable<Awaited<ReturnType<typeof checkIn>>>
    
    export type CheckInMutationError = AxiosError<unknown>

    /**
 * @summary ì¶œì„ ì²´í¬
 */
export const useCheckIn = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkIn>>, TError,void, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof checkIn>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getCheckInMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary ë‚´ ê³¼ì œ ëª©ë¡
 */
export const getMyAssignments = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AssignmentSummaryResponse[]>> => {
    
    
    return axios.default.get(
      `/api/student/assignments`,options
    );
  }




export const getGetMyAssignmentsQueryKey = () => {
    return [
    `/api/student/assignments`
    ] as const;
    }

    
export const getGetMyAssignmentsQueryOptions = <TData = Awaited<ReturnType<typeof getMyAssignments>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMyAssignments>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMyAssignmentsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyAssignments>>> = ({ signal }) => getMyAssignments({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMyAssignments>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMyAssignmentsQueryResult = NonNullable<Awaited<ReturnType<typeof getMyAssignments>>>
export type GetMyAssignmentsQueryError = AxiosError<unknown>


/**
 * @summary ë‚´ ê³¼ì œ ëª©ë¡
 */

export function useGetMyAssignments<TData = Awaited<ReturnType<typeof getMyAssignments>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMyAssignments>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetMyAssignmentsQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary ë‚´ ì‹œí—˜ ëª©ë¡
 */
export const getMyExams = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ExamSummaryResponse[]>> => {
    
    
    return axios.default.get(
      `/api/student/exams`,options
    );
  }




export const getGetMyExamsQueryKey = () => {
    return [
    `/api/student/exams`
    ] as const;
    }

    
export const getGetMyExamsQueryOptions = <TData = Awaited<ReturnType<typeof getMyExams>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMyExams>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMyExamsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyExams>>> = ({ signal }) => getMyExams({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMyExams>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMyExamsQueryResult = NonNullable<Awaited<ReturnType<typeof getMyExams>>>
export type GetMyExamsQueryError = AxiosError<unknown>


/**
 * @summary ë‚´ ì‹œí—˜ ëª©ë¡
 */

export function useGetMyExams<TData = Awaited<ReturnType<typeof getMyExams>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMyExams>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetMyExamsQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary í•™ìƒ í†µí•© ë¶„ì„ ë¦¬í¬íŠ¸ ì¡°íšŒ
 */
export const getStudentAnalysis = (
    studentId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<StudentAnalysisResponse>> => {
    
    
    return axios.default.get(
      `/api/analysis/student/${studentId}`,options
    );
  }




export const getGetStudentAnalysisQueryKey = (studentId?: number,) => {
    return [
    `/api/analysis/student/${studentId}`
    ] as const;
    }

    
export const getGetStudentAnalysisQueryOptions = <TData = Awaited<ReturnType<typeof getStudentAnalysis>>, TError = AxiosError<void>>(studentId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getStudentAnalysis>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStudentAnalysisQueryKey(studentId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStudentAnalysis>>> = ({ signal }) => getStudentAnalysis(studentId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(studentId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getStudentAnalysis>>, TError, TData> & { queryKey: QueryKey }
}

export type GetStudentAnalysisQueryResult = NonNullable<Awaited<ReturnType<typeof getStudentAnalysis>>>
export type GetStudentAnalysisQueryError = AxiosError<void>


/**
 * @summary í•™ìƒ í†µí•© ë¶„ì„ ë¦¬í¬íŠ¸ ì¡°íšŒ
 */

export function useGetStudentAnalysis<TData = Awaited<ReturnType<typeof getStudentAnalysis>>, TError = AxiosError<void>>(
 studentId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getStudentAnalysis>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetStudentAnalysisQueryOptions(studentId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary í•™ìƒ ì „ì²´ ì‹œí—˜ ìš”ì•½ ì¡°íšŒ
 */
export const getExamSummary = (
    studentId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<StudentExamSummaryResponse[]>> => {
    
    
    return axios.default.get(
      `/api/students/${studentId}/analysis/exams`,options
    );
  }




export const getGetExamSummaryQueryKey = (studentId?: number,) => {
    return [
    `/api/students/${studentId}/analysis/exams`
    ] as const;
    }

    
export const getGetExamSummaryQueryOptions = <TData = Awaited<ReturnType<typeof getExamSummary>>, TError = AxiosError<void>>(studentId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getExamSummary>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetExamSummaryQueryKey(studentId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getExamSummary>>> = ({ signal }) => getExamSummary(studentId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(studentId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getExamSummary>>, TError, TData> & { queryKey: QueryKey }
}

export type GetExamSummaryQueryResult = NonNullable<Awaited<ReturnType<typeof getExamSummary>>>
export type GetExamSummaryQueryError = AxiosError<void>


/**
 * @summary í•™ìƒ ì „ì²´ ì‹œí—˜ ìš”ì•½ ì¡°íšŒ
 */

export function useGetExamSummary<TData = Awaited<ReturnType<typeof getExamSummary>>, TError = AxiosError<void>>(
 studentId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getExamSummary>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetExamSummaryQueryOptions(studentId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary í•™ìƒì˜ ë‹¨ì›ë³„ ì„±ì·¨ë„ ì¡°íšŒ (ì •ë‹µë¥  ë‚®ì€ ìˆœ)
 */
export const getWeakUnits = (
    studentId: number,
    params?: GetWeakUnitsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<StudentUnitCorrectRateResponse[]>> => {
    
    
    return axios.default.get(
      `/api/students/${studentId}/analysis/weak-units`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getGetWeakUnitsQueryKey = (studentId?: number,
    params?: GetWeakUnitsParams,) => {
    return [
    `/api/students/${studentId}/analysis/weak-units`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetWeakUnitsQueryOptions = <TData = Awaited<ReturnType<typeof getWeakUnits>>, TError = AxiosError<void>>(studentId: number,
    params?: GetWeakUnitsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getWeakUnits>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWeakUnitsQueryKey(studentId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWeakUnits>>> = ({ signal }) => getWeakUnits(studentId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(studentId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWeakUnits>>, TError, TData> & { queryKey: QueryKey }
}

export type GetWeakUnitsQueryResult = NonNullable<Awaited<ReturnType<typeof getWeakUnits>>>
export type GetWeakUnitsQueryError = AxiosError<void>


/**
 * @summary í•™ìƒì˜ ë‹¨ì›ë³„ ì„±ì·¨ë„ ì¡°íšŒ (ì •ë‹µë¥  ë‚®ì€ ìˆœ)
 */

export function useGetWeakUnits<TData = Awaited<ReturnType<typeof getWeakUnits>>, TError = AxiosError<void>>(
 studentId: number,
    params?: GetWeakUnitsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getWeakUnits>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetWeakUnitsQueryOptions(studentId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary í•™ìƒì˜ ê°•ì˜ë³„ ì›”ê°„ ì¶œì„ í˜„í™© ì¡°íšŒ
 */
export const getMonthlyAttendance = (
    studentId: number,
    lectureId: number,
    params: GetMonthlyAttendanceParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<StudentLectureAttendanceResponse>> => {
    
    
    return axios.default.get(
      `/api/students/${studentId}/lectures/${lectureId}/attendance/monthly`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getGetMonthlyAttendanceQueryKey = (studentId?: number,
    lectureId?: number,
    params?: GetMonthlyAttendanceParams,) => {
    return [
    `/api/students/${studentId}/lectures/${lectureId}/attendance/monthly`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetMonthlyAttendanceQueryOptions = <TData = Awaited<ReturnType<typeof getMonthlyAttendance>>, TError = AxiosError<void>>(studentId: number,
    lectureId: number,
    params: GetMonthlyAttendanceParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMonthlyAttendance>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMonthlyAttendanceQueryKey(studentId,lectureId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMonthlyAttendance>>> = ({ signal }) => getMonthlyAttendance(studentId,lectureId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(studentId && lectureId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMonthlyAttendance>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMonthlyAttendanceQueryResult = NonNullable<Awaited<ReturnType<typeof getMonthlyAttendance>>>
export type GetMonthlyAttendanceQueryError = AxiosError<void>


/**
 * @summary í•™ìƒì˜ ê°•ì˜ë³„ ì›”ê°„ ì¶œì„ í˜„í™© ì¡°íšŒ
 */

export function useGetMonthlyAttendance<TData = Awaited<ReturnType<typeof getMonthlyAttendance>>, TError = AxiosError<void>>(
 studentId: number,
    lectureId: number,
    params: GetMonthlyAttendanceParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMonthlyAttendance>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetMonthlyAttendanceQueryOptions(studentId,lectureId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}
